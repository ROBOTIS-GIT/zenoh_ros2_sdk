{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"zenoh-ros2-sdk","text":"<p>Python SDK for ROS 2 communication via Zenoh \u2014 use ROS 2 without a ROS 2 environment.</p> <p>This SDK lets pure-Python apps publish/subscribe to ROS 2 topics and offer/call ROS 2 services over Zenoh in a way that is compatible with <code>rmw_zenoh</code> discovery (topics/services show up in ROS tools).</p>"},{"location":"#quick-start","title":"Quick start","text":"<p>Install:</p> <pre><code>pip install zenoh-ros2-sdk\n</code></pre> <p>Publish:</p> <pre><code>from zenoh_ros2_sdk import ROS2Publisher\n\npub = ROS2Publisher(topic=\"/chatter\", msg_type=\"std_msgs/msg/String\")\npub.publish(data=\"Hello from zenoh-ros2-sdk\")\npub.close()\n</code></pre> <p>Subscribe:</p> <pre><code>from zenoh_ros2_sdk import ROS2Subscriber\n\ndef on_msg(msg):\n    print(msg.data)\n\nsub = ROS2Subscriber(\n    topic=\"/chatter\",\n    msg_type=\"std_msgs/msg/String\",\n    callback=on_msg\n)\n</code></pre>"},{"location":"#where-to-go-next","title":"Where to go next","text":"<ul> <li>Getting Started: installation, running a router, pub/sub and services (<code>getting-started.md</code>)</li> <li>Concepts: domain IDs, discovery tokens, key expressions, QoS (<code>concepts.md</code>)</li> <li>Examples: runnable scripts you can copy/paste (<code>examples.md</code>)</li> <li>API Reference: full API from docstrings (<code>api/index.md</code>)</li> </ul>"},{"location":"concepts/","title":"Concepts","text":"<p>This SDK follows the same conventions as <code>rmw_zenoh_cpp</code> / <code>ros-z</code> so ROS tools can discover entities and (when applicable) publishers can behave like ROS 2 \u201cpublish-on-subscribe\u201d.</p>"},{"location":"concepts/#domain-id","title":"Domain ID","text":"<p>ROS 2 uses a domain ID to isolate graphs. In this SDK you typically pass <code>domain_id</code> to publishers/subscribers/service endpoints. You must use the same <code>domain_id</code> as the ROS 2 side you want to communicate with. If you do not pass <code>domain_id</code> to the constructor, the SDK uses <code>ROS_DOMAIN_ID</code> from the environment (falling back to 0 when it is not set). An explicit <code>domain_id</code> argument always overrides the environment value.</p>"},{"location":"concepts/#types-and-type-hashes","title":"Types and type hashes","text":"<p>You specify types as ROS 2 strings like:</p> <ul> <li><code>std_msgs/msg/String</code></li> <li><code>example_interfaces/srv/AddTwoInts</code></li> </ul> <p>The SDK can auto-load message/service definitions (via the message registry) and compute ROS 2 compatible type hashes.</p>"},{"location":"concepts/#discovery-vs-data-transport","title":"Discovery vs data transport","text":"<ul> <li>Discovery-plane: liveliness tokens under <code>@ros2_lv/...</code> advertise nodes, publishers, subscribers, service servers, and service clients so they appear in the ROS graph.</li> <li>Data-plane: serialized CDR payloads are transported over Zenoh key expressions derived from the topic/service name, type, and type hash.</li> </ul>"},{"location":"concepts/#qos","title":"QoS","text":"<p>For graph compatibility, QoS information is encoded into discovery tokens using the compact <code>rmw_zenoh</code> / <code>ros-z</code> format.</p> <p>In most APIs you can pass either:</p> <ul> <li>a <code>QosProfile</code> object (from <code>zenoh_ros2_sdk.qos</code>), or</li> <li>a pre-encoded QoS string.</li> </ul>"},{"location":"concepts/#sessions","title":"Sessions","text":"<p>Publishers/subscribers/service endpoints share an underlying Zenoh session for efficiency (session pooling). Close resources when you\u2019re done (<code>.close()</code>).</p>"},{"location":"examples/","title":"Examples","text":"<p>The repo contains runnable scripts in <code>examples/</code> (numbered in recommended learning order).</p> <p>Start a router in a ROS2 environment:</p> <pre><code>ros2 run rmw_zenoh_cpp rmw_zenohd\n</code></pre> <p>Run an example:</p> <pre><code>python3 examples/01_publish_string.py\npython3 examples/02_subscribe_string.py\n</code></pre> <p>For the full list (including services, queue-mode services, and compressed image subscription), see <code>examples/README.md</code>.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This page is about using the SDK (pub/sub/services). If you want to build the documentation site itself, see <code>contributing/docs.md</code>.</p>"},{"location":"getting-started/#install","title":"Install","text":"<p>From PyPI:</p> <pre><code>pip install zenoh-ros2-sdk\n</code></pre> <p>From source (editable):</p> <pre><code>pip install -e .\n</code></pre>"},{"location":"getting-started/#start-a-zenoh-router-optional-but-common","title":"Start a Zenoh router (optional but common)","text":"<p>Many setups use a local router. Execute the Zenoh router in a ROS2 environment:</p> <pre><code>ros2 run rmw_zenoh_cpp rmw_zenohd\n</code></pre> <p>If you are connecting to a remote router, pass <code>router_ip</code> / <code>router_port</code> when creating publishers/subscribers/service endpoints.</p>"},{"location":"getting-started/#publish-a-topic","title":"Publish a topic","text":"<pre><code>from zenoh_ros2_sdk import ROS2Publisher\n\npub = ROS2Publisher(\n    topic=\"/chatter\",\n    msg_type=\"std_msgs/msg/String\"\n)\npub.publish(data=\"Hello World!\")\npub.close()\n</code></pre>"},{"location":"getting-started/#subscribe-to-a-topic","title":"Subscribe to a topic","text":"<pre><code>from zenoh_ros2_sdk import ROS2Subscriber\n\ndef on_message(msg):\n    print(f\"Received: {msg.data}\")\n\nsub = ROS2Subscriber(\n    topic=\"/chatter\",\n    msg_type=\"std_msgs/msg/String\",\n    callback=on_message\n)\n</code></pre>"},{"location":"getting-started/#service-server","title":"Service server","text":"<pre><code>from zenoh_ros2_sdk import ROS2ServiceServer, get_message_class\n\ndef handler(request):\n    Response = get_message_class(\"example_interfaces/srv/AddTwoInts_Response\")\n    return Response(sum=request.a + request.b)\n\nserver = ROS2ServiceServer(\n    service_name=\"/add_two_ints\",\n    srv_type=\"example_interfaces/srv/AddTwoInts\",\n    callback=handler\n)\n</code></pre>"},{"location":"getting-started/#service-client","title":"Service client","text":"<pre><code>from zenoh_ros2_sdk import ROS2ServiceClient\n\nclient = ROS2ServiceClient(\n    service_name=\"/add_two_ints\",\n    srv_type=\"example_interfaces/srv/AddTwoInts\"\n)\n\nresp = client.call(a=5, b=3)\nif resp:\n    print(resp.sum)\nclient.close()\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next steps","text":"<ul> <li>For runnable scripts (including queue-mode services and compressed image subscription), see <code>examples.md</code>.</li> <li>For how discovery/QoS/key-expressions work, see <code>concepts.md</code>.</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>The pages below are generated from the <code>zenoh_ros2_sdk</code> package docstrings.</p>"},{"location":"api/attachment/","title":"<code>attachment</code>","text":"<p>Attachment utilities compatible with rmw_zenoh / ros-z.</p> <p>Binary format (little-endian), matching our existing implementation:   u64 sequence_number   u64 timestamp_ns   u8  gid_len   u8[gid_len] gid</p> <p>Used for: - Topic publications (publisher attachment) - Service requests/responses (required for correlation; server replies with the same sequence_id+gid)</p>"},{"location":"api/attachment/#zenoh_ros2_sdk.attachment.Attachment","title":"<code>Attachment</code>","text":"<p>Service/topic attachment compatible with rmw_zenoh.</p> <p>Attributes:</p> Name Type Description <code>sequence_id</code> <code>int</code> <p>Per-client/publisher sequence number.</p> <code>timestamp_ns</code> <code>int</code> <p>Source timestamp in nanoseconds.</p> <code>gid</code> <code>bytes</code> <p>Source GID (bytes, length &lt;= 255).</p> Source code in <code>zenoh_ros2_sdk/attachment.py</code> <pre><code>@slotted_dataclass(frozen=True)\nclass Attachment:\n    \"\"\"Service/topic attachment compatible with rmw_zenoh.\n\n    Attributes:\n        sequence_id: Per-client/publisher sequence number.\n        timestamp_ns: Source timestamp in nanoseconds.\n        gid: Source GID (bytes, length &lt;= 255).\n    \"\"\"\n    sequence_id: int\n    timestamp_ns: int\n    gid: bytes\n\n    def to_bytes(self) -&gt; bytes:\n        if not isinstance(self.gid, (bytes, bytearray)):\n            raise TypeError(f\"gid must be bytes, got {type(self.gid)}\")\n        gid_b = bytes(self.gid)\n        if len(gid_b) &gt; 255:\n            raise ValueError(f\"gid too long for attachment encoding: {len(gid_b)}\")\n        return (\n            struct.pack(\"&lt;Q\", int(self.sequence_id))\n            + struct.pack(\"&lt;Q\", int(self.timestamp_ns))\n            + struct.pack(\"B\", len(gid_b))\n            + gid_b\n        )\n\n    @staticmethod\n    def from_bytes(b: bytes) -&gt; \"Attachment\":\n        if not isinstance(b, (bytes, bytearray)):\n            raise TypeError(f\"attachment must be bytes, got {type(b)}\")\n        b = bytes(b)\n        if len(b) &lt; 17:\n            raise ValueError(\"attachment too short (need at least 17 bytes)\")\n        seq = struct.unpack(\"&lt;Q\", b[0:8])[0]\n        ts = struct.unpack(\"&lt;Q\", b[8:16])[0]\n        gid_len = struct.unpack(\"B\", b[16:17])[0]\n        if len(b) &lt; 17 + gid_len:\n            raise ValueError(\"attachment truncated (gid_len exceeds available bytes)\")\n        gid = b[17 : 17 + gid_len]\n        return Attachment(sequence_id=seq, timestamp_ns=ts, gid=gid)\n</code></pre>"},{"location":"api/entity/","title":"<code>entity</code>","text":"<p>Entity models aligned with rmw_zenoh_cpp / ros-z concepts.</p> <p>This module intentionally keeps formatting and keyexpr construction out of the publisher/subscriber implementations so that: - all liveliness tokens are consistent (NN/MP/MS/SS/SC) - all topic/service key expressions are constructed in one place</p>"},{"location":"api/entity/#zenoh_ros2_sdk.entity.EntityKind","title":"<code>EntityKind</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Matches rmw_zenoh_cpp / ros-z entity kind strings.</p> Source code in <code>zenoh_ros2_sdk/entity.py</code> <pre><code>class EntityKind(str, Enum):\n    \"\"\"Matches rmw_zenoh_cpp / ros-z entity kind strings.\"\"\"\n\n    NODE = \"NN\"\n    PUBLISHER = \"MP\"\n    SUBSCRIPTION = \"MS\"\n    SERVICE = \"SS\"\n    CLIENT = \"SC\"\n</code></pre>"},{"location":"api/entity/#zenoh_ros2_sdk.entity.EndpointEntity","title":"<code>EndpointEntity</code>","text":"<p>Represents a ROS graph endpoint (pub/sub/service/client) attached to a node.</p> <ul> <li>For topics: <code>name</code> is the ROS topic name (e.g. \"/chatter\")</li> <li>For services: <code>name</code> is the ROS service name (e.g. \"/add_two_ints\")</li> </ul> Source code in <code>zenoh_ros2_sdk/entity.py</code> <pre><code>@slotted_dataclass(frozen=True)\nclass EndpointEntity:\n    \"\"\"\n    Represents a ROS graph endpoint (pub/sub/service/client) attached to a node.\n\n    - For topics: `name` is the ROS topic name (e.g. \"/chatter\")\n    - For services: `name` is the ROS service name (e.g. \"/add_two_ints\")\n    \"\"\"\n\n    node: NodeEntity\n    entity_id: int\n    kind: EntityKind\n    name: str\n    dds_type_name: str\n    type_hash: str\n    qos: str\n    gid: Optional[bytes] = None\n</code></pre>"},{"location":"api/keyexpr/","title":"<code>keyexpr</code>","text":"<p>Key expression builders aligned with rmw_zenoh_cpp design.md and ros-z implementation.</p>"},{"location":"api/keyexpr/#zenoh_ros2_sdk.keyexpr.topic_keyexpr","title":"<code>topic_keyexpr(domain_id: int, fully_qualified_name: str, dds_type_name: str, type_hash: str) -&gt; str</code>","text":"<p>Data-plane key expression for topics/services.</p> Format <p>/// Source code in <code>zenoh_ros2_sdk/keyexpr.py</code> <pre><code>def topic_keyexpr(domain_id: int, fully_qualified_name: str, dds_type_name: str, type_hash: str) -&gt; str:\n    \"\"\"\n    Data-plane key expression for topics/services.\n\n    Format:\n      &lt;domain_id&gt;/&lt;fully_qualified_name&gt;/&lt;type_name&gt;/&lt;type_hash&gt;\n    \"\"\"\n    return f\"{domain_id}/{fully_qualified_name.lstrip('/')}/{dds_type_name}/{type_hash}\"\n</code></pre>"},{"location":"api/keyexpr/#zenoh_ros2_sdk.keyexpr.node_liveliness_keyexpr","title":"<code>node_liveliness_keyexpr(node: NodeEntity) -&gt; str</code>","text":"<p>Liveliness token for a node.</p> Format <p>@ros2_lv/////NN/// Source code in <code>zenoh_ros2_sdk/keyexpr.py</code> <pre><code>def node_liveliness_keyexpr(node: NodeEntity) -&gt; str:\n    \"\"\"\n    Liveliness token for a node.\n\n    Format:\n      @ros2_lv/&lt;domain_id&gt;/&lt;session_id&gt;/&lt;node_id&gt;/&lt;node_id&gt;/NN/&lt;enclave&gt;/&lt;namespace&gt;/&lt;node_name&gt;\n    \"\"\"\n    namespace = mangle_name(node.namespace)\n    name = mangle_name(node.node_name)\n    enclave = node.enclave if node.enclave else \"%\"\n    return (\n        f\"{ADMIN_SPACE}/{node.domain_id}/{node.session_id}/\"\n        f\"{node.node_id}/{node.node_id}/{EntityKind.NODE.value}/\"\n        f\"{enclave}/{namespace}/{name}\"\n    )\n</code></pre>"},{"location":"api/keyexpr/#zenoh_ros2_sdk.keyexpr.endpoint_liveliness_keyexpr","title":"<code>endpoint_liveliness_keyexpr(ep: EndpointEntity) -&gt; str</code>","text":"<p>Liveliness token for a publisher/subscriber/service/client.</p> Format <p>@ros2_lv///////// /// Source code in <code>zenoh_ros2_sdk/keyexpr.py</code> <pre><code>def endpoint_liveliness_keyexpr(ep: EndpointEntity) -&gt; str:\n    \"\"\"\n    Liveliness token for a publisher/subscriber/service/client.\n\n    Format:\n      @ros2_lv/&lt;domain_id&gt;/&lt;session_id&gt;/&lt;node_id&gt;/&lt;entity_id&gt;/&lt;kind&gt;/&lt;enclave&gt;/&lt;namespace&gt;/&lt;node_name&gt;/\n      &lt;mangled_qualified_name&gt;/&lt;type_name&gt;/&lt;type_hash&gt;/&lt;qos&gt;\n    \"\"\"\n    node = ep.node\n    namespace = mangle_name(node.namespace)\n    node_name = mangle_name(node.node_name)\n    qualified_name = mangle_name(ep.name)\n    enclave = node.enclave if node.enclave else \"%\"\n    return (\n        f\"{ADMIN_SPACE}/{node.domain_id}/{node.session_id}/\"\n        f\"{node.node_id}/{ep.entity_id}/{ep.kind.value}/\"\n        f\"{enclave}/{namespace}/{node_name}/\"\n        f\"{qualified_name}/{ep.dds_type_name}/{ep.type_hash}/{ep.qos}\"\n    )\n</code></pre>"},{"location":"api/message_registry/","title":"<code>message_registry</code>","text":"<p>Message Registry - Loads and manages ROS2 message definitions from .msg files</p>"},{"location":"api/message_registry/#zenoh_ros2_sdk.message_registry.MessageRegistry","title":"<code>MessageRegistry</code>","text":"<p>Registry for loading and managing ROS2 message definitions</p> Source code in <code>zenoh_ros2_sdk/message_registry.py</code> <pre><code>class MessageRegistry:\n    \"\"\"Registry for loading and managing ROS2 message definitions\"\"\"\n\n    def __init__(self, messages_dir: Optional[str] = None):\n        \"\"\"\n        Initialize message registry\n\n        Args:\n            messages_dir: Directory containing message files (default: SDK messages directory)\n        \"\"\"\n        if messages_dir is None:\n            # Default to SDK's messages directory\n            sdk_dir = Path(__file__).parent.parent\n            messages_dir = str(sdk_dir / \"messages\")\n\n        self.messages_dir = Path(messages_dir)\n        # Import at module level (no lazy loading)\n        # We use a property to get the session dynamically to ensure we always use the current session\n        # (important when singleton is reset in tests)\n        from .session import ZenohSession\n        self._ZenohSession = ZenohSession  # Store class reference\n        self._loaded_types: Set[str] = set()\n\n    @property\n    def session(self):\n        \"\"\"Get the current ZenohSession instance (always fresh)\"\"\"\n        return self._ZenohSession.get_instance()\n\n    def get_msg_file_path(self, msg_type: str) -&gt; Optional[Path]:\n        \"\"\"\n        Get the path to a .msg file for a given message type.\n        First checks local messages directory, then tries to download from git.\n\n        Args:\n            msg_type: ROS2 message type (e.g., \"geometry_msgs/msg/Vector3\")\n\n        Returns:\n            Path to .msg file or None if not found\n        \"\"\"\n        parts = msg_type.split(\"/\")\n        if len(parts) != 3:\n            return None\n\n        namespace, msg, message_name = parts\n\n        # First, check local messages directory\n        msg_file = self.messages_dir / namespace / msg / f\"{message_name}.msg\"\n        if msg_file.exists():\n            return msg_file\n\n        # If not found locally, try to download from git repository\n        try:\n            # Find which repository contains this package\n            repo_name = get_repository_for_package(namespace)\n            if repo_name:\n                git_path = get_message_file_path(msg_type, repo_name)\n                if git_path and os.path.exists(git_path):\n                    return Path(git_path)\n        except ImportError as e:\n            # GitPython not available - log warning but don't fail\n            logger.warning(\n                f\"GitPython not available. Cannot auto-download message file for {msg_type}. \"\n                f\"Install GitPython with 'pip install GitPython' to enable auto-download. \"\n                f\"Error: {e}\"\n            )\n        except Exception as e:\n            # Log the error but don't fail - user can add message manually\n            logger.warning(\n                f\"Failed to auto-download message file for {msg_type} from git repository: {e}. \"\n                f\"You may need to add the message file manually.\"\n            )\n\n        return None\n\n    def get_srv_file_path(self, srv_type: str, is_request: bool = True) -&gt; Optional[Path]:\n        \"\"\"\n        Get the path to a .srv file for a given service type.\n        First checks local messages directory, then tries to download from git.\n\n        Args:\n            srv_type: ROS2 service type (e.g., \"example_interfaces/srv/AddTwoInts\")\n            is_request: If True, return path for request part; if False, for response part\n\n        Returns:\n            Path to .srv file or None if not found\n        \"\"\"\n        parts = srv_type.split(\"/\")\n        if len(parts) != 3:\n            return None\n\n        namespace, srv, service_name = parts\n\n        # First, check local messages directory\n        srv_file = self.messages_dir / namespace / srv / f\"{service_name}.srv\"\n        if srv_file.exists():\n            return srv_file\n\n        # If not found locally, try to download from git repository\n        try:\n            # Find which repository contains this package\n            repo_name = get_repository_for_package(namespace)\n            if repo_name:\n                try:\n                    repo_path = clone_to_cache(repo_name)\n                    repository = MESSAGE_REPOSITORIES[repo_name]\n\n                    # Construct path to service file using shared helper function\n                    srv_file_path = construct_message_path(\n                        repo_path, repository, namespace, srv, service_name\n                    )\n\n                    if os.path.exists(srv_file_path):\n                        return Path(srv_file_path)\n                except Exception as e:\n                    logger.warning(\n                        f\"Failed to get service file from cache for {srv_type}: {e}. \"\n                        f\"Trying to clone repository...\"\n                    )\n        except ImportError as e:\n            # GitPython not available - log warning but don't fail\n            logger.warning(\n                f\"GitPython not available. Cannot auto-download service file for {srv_type}. \"\n                f\"Install GitPython with 'pip install GitPython' to enable auto-download. \"\n                f\"Error: {e}\"\n            )\n        except Exception as e:\n            # Log the error but don't fail - user can add message manually\n            logger.warning(\n                f\"Failed to auto-download service file for {srv_type} from git repository: {e}. \"\n                f\"You may need to add the service file manually.\"\n            )\n\n        return None\n\n    def _load_service_types(self, srv_type: str, visited: Optional[Set[str]] = None):\n        \"\"\"\n        Load service request and response types from a .srv file\n\n        Args:\n            srv_type: ROS2 service type (e.g., \"example_interfaces/srv/AddTwoInts\")\n            visited: Set of already visited types to prevent cycles\n        \"\"\"\n        if visited is None:\n            visited = set()\n\n        # Parse service type to get request and response types\n        parts = srv_type.split(\"/\")\n        if len(parts) != 3:\n            raise ValueError(f\"Invalid service type format: {srv_type}\")\n\n        namespace_part, srv, service_name_part = parts\n        request_type = f\"{namespace_part}/srv/{service_name_part}_Request\"\n        response_type = f\"{namespace_part}/srv/{service_name_part}_Response\"\n\n        if request_type in visited or response_type in visited:\n            return\n\n        visited.add(request_type)\n        visited.add(response_type)\n\n        # Load the service file\n        srv_file = self.get_srv_file_path(srv_type)\n        if not srv_file:\n            raise FileNotFoundError(\n                f\"Service file not found for type: {srv_type}. \"\n                f\"Please ensure the service type is available in the message registry or provide the service definition manually.\"\n            )\n\n        # Read service definition\n        try:\n            with open(srv_file, 'r') as f:\n                srv_definition = f.read()\n        except Exception as e:\n            raise IOError(f\"Failed to read service file {srv_file}: {e}\") from e\n\n        # Split into request and response parts\n        parts = srv_definition.split('---')\n        if len(parts) != 2:\n            raise ValueError(\n                f\"Invalid service file format for {srv_type}: expected '---' separator. \"\n                f\"Found {len(parts)} parts instead of 2.\"\n            )\n\n        request_definition = parts[0].strip()\n        response_definition = parts[1].strip()\n\n        if not request_definition:\n            raise ValueError(f\"Empty request definition in service file for {srv_type}\")\n        if not response_definition:\n            raise ValueError(f\"Empty response definition in service file for {srv_type}\")\n\n        # Extract dependencies for request and response\n        request_deps = self._extract_dependencies(request_definition, request_type)\n        response_deps = self._extract_dependencies(response_definition, response_type)\n\n        # Load dependencies first\n        for dep_type in request_deps + response_deps:\n            if dep_type not in self._loaded_types and dep_type not in visited:\n                try:\n                    self._load_dependencies(dep_type, visited.copy())\n                except Exception as e:\n                    logger.error(\n                        f\"Failed to load dependency {dep_type} for service {srv_type}: {e}. \"\n                        f\"This may cause service type registration to fail.\"\n                    )\n                    # Continue loading other dependencies, but log the error\n                    # The registration will fail later if the dependency is truly required\n\n        # Register request and response types\n        try:\n            if request_type not in self.session._registered_types:\n                self.session.register_message_type(request_definition, request_type)\n            if response_type not in self.session._registered_types:\n                self.session.register_message_type(response_definition, response_type)\n        except Exception as e:\n            raise RuntimeError(\n                f\"Failed to register service types for {srv_type}: {e}. \"\n                f\"Request type: {request_type}, Response type: {response_type}\"\n            ) from e\n\n        self._loaded_types.add(request_type)\n        self._loaded_types.add(response_type)\n\n    def load_service_type(self, srv_type: str) -&gt; bool:\n        \"\"\"\n        Load a service type (request and response) and their dependencies\n\n        Args:\n            srv_type: ROS2 service type (e.g., \"example_interfaces/srv/AddTwoInts\")\n\n        Returns:\n            True if loaded successfully, False otherwise\n        \"\"\"\n        try:\n            self._load_service_types(srv_type)\n            return True\n        except Exception as e:\n            logger.warning(f\"Failed to load service type {srv_type}: {e}\", exc_info=True)\n            return False\n\n    def _load_dependencies(self, msg_type: str, visited: Optional[Set[str]] = None):\n        \"\"\"\n        Recursively load message type and its dependencies\n\n        Args:\n            msg_type: ROS2 message type to load\n            visited: Set of already visited types to prevent cycles\n        \"\"\"\n        if visited is None:\n            visited = set()\n\n        if msg_type in visited or msg_type in self._loaded_types:\n            return\n\n        visited.add(msg_type)\n\n        # Load the message file (checks local first, then downloads from git if needed)\n        msg_file = self.get_msg_file_path(msg_type)\n        if not msg_file:\n            # Try one more time after potential download\n            msg_file = self.get_msg_file_path(msg_type)\n            if not msg_file:\n                # Message file not found - raise exception so it can be caught and logged\n                raise FileNotFoundError(f\"Message file not found for type: {msg_type}\")\n\n        # Read message definition\n        with open(msg_file, 'r') as f:\n            msg_definition = f.read()\n\n        # Parse dependencies from the message definition\n        dependencies = self._extract_dependencies(msg_definition, msg_type)\n\n        # Load dependencies first (recursively)\n        for dep_type in dependencies:\n            if dep_type not in self._loaded_types:\n                self._load_dependencies(dep_type, visited.copy())\n\n        # Register this message type (only if not already registered)\n        if msg_type not in self.session._registered_types:\n            self.session.register_message_type(msg_definition, msg_type)\n        self._loaded_types.add(msg_type)\n\n    def _extract_dependencies(self, msg_definition: str, current_type: str) -&gt; list:\n        \"\"\"\n        Extract message type dependencies from a message definition\n\n        Args:\n            msg_definition: Message definition text\n            current_type: Current message type (for namespace resolution)\n\n        Returns:\n            List of dependency message types\n        \"\"\"\n        dependencies = []\n        parts = current_type.split(\"/\")\n        if len(parts) != 3:\n            return dependencies\n\n        namespace, _, _ = parts\n\n        # Parse lines to find type references\n        for line in msg_definition.split('\\n'):\n            # Remove comments first\n            if '#' in line:\n                line = line[:line.index('#')]\n            line = line.strip()\n            # Skip empty lines\n            if not line:\n                continue\n\n            # Skip separator lines\n            if line.startswith('---'):\n                continue\n\n            # Check for type references (format: TypeName field_name)\n            words = line.split()\n            if len(words) &gt;= 2:\n                type_name = words[0]\n\n                # Strip array notation: string[] -&gt; string, geometry_msgs/msg/Vector3[10] -&gt; geometry_msgs/msg/Vector3\n                base_type = type_name\n                if '[' in type_name:\n                    base_type = type_name.split('[')[0]\n\n                # Check if it's a custom type (not a primitive)\n                primitives = ['bool', 'int8', 'uint8', 'int16', 'uint16',\n                            'int32', 'uint32', 'int64', 'uint64',\n                            'float32', 'float64', 'string', 'time', 'duration',\n                            'byte', 'char', 'wchar', 'wstring', 'octet']\n\n                if base_type not in primitives and not base_type.startswith('['):\n                    # Resolve namespace\n                    if '/' in base_type:\n                        # Could be: builtin_interfaces/Time or geometry_msgs/msg/Vector3\n                        parts = base_type.split('/')\n                        if len(parts) == 2:\n                            # Format: namespace/TypeName -&gt; convert to namespace/msg/TypeName\n                            dep_type = f\"{parts[0]}/msg/{parts[1]}\"\n                        else:\n                            # Already full path: namespace/msg/TypeName\n                            dep_type = base_type\n                    else:\n                        # Short name: assume same namespace\n                        dep_type = f\"{namespace}/msg/{base_type}\"\n\n                    if dep_type not in dependencies:\n                        dependencies.append(dep_type)\n\n        return dependencies\n\n    def load_message_type(self, msg_type: str) -&gt; bool:\n        \"\"\"\n        Load a message type and its dependencies\n\n        Args:\n            msg_type: ROS2 message type (e.g., \"geometry_msgs/msg/Twist\")\n\n        Returns:\n            True if loaded successfully, False otherwise\n        \"\"\"\n        try:\n            self._load_dependencies(msg_type)\n            return True\n        except Exception as e:\n            logger.warning(f\"Failed to load message type {msg_type}: {e}\")\n            return False\n\n    def get_message_class(self, msg_type: str) -&gt; Optional[Type[Any]]:\n        \"\"\"\n        Get a message class for a given type (loads if not already loaded)\n\n        Args:\n            msg_type: ROS2 message type\n\n        Returns:\n            Optional[Type[Any]]: Message class or None if not found\n        \"\"\"\n        if msg_type not in self._loaded_types:\n            # Service request/response types cannot be loaded from a single .msg file path.\n            # They must be loaded from the parent .srv file.\n            is_service_req_resp = (\n                \"/srv/\" in msg_type and (msg_type.endswith(\"_Request\") or msg_type.endswith(\"_Response\"))\n            )\n            if is_service_req_resp:\n                # example_interfaces/srv/AddTwoInts_Request -&gt; example_interfaces/srv/AddTwoInts\n                if msg_type.endswith(\"_Request\"):\n                    base_srv = msg_type[:-8]\n                else:\n                    base_srv = msg_type[:-9]\n                if not self.load_service_type(base_srv):\n                    return None\n            else:\n                if not self.load_message_type(msg_type):\n                    return None\n\n        # Check if we have a mapping to the actual store key (for service types)\n        actual_key = self.session._registered_types.get(msg_type)\n        if actual_key and isinstance(actual_key, str):\n            # actual_key is the store key (may be converted name)\n            return self.session.store.types.get(actual_key)\n\n        # Try direct lookup\n        msg_class = self.session.store.types.get(msg_type)\n        if msg_class is not None:\n            return msg_class\n\n        # Try with /msg/ inserted (for service types: srv/ -&gt; srv/msg/)\n        if '/srv/' in msg_type:\n            converted_name = msg_type.replace('/srv/', '/srv/msg/')\n            return self.session.store.types.get(converted_name)\n\n        return None\n\n    def is_loaded(self, msg_type: str) -&gt; bool:\n        \"\"\"Check if a message type is already loaded\"\"\"\n        return msg_type in self._loaded_types\n</code></pre>"},{"location":"api/message_registry/#zenoh_ros2_sdk.message_registry.MessageRegistry.session","title":"<code>session</code>  <code>property</code>","text":"<p>Get the current ZenohSession instance (always fresh)</p>"},{"location":"api/message_registry/#zenoh_ros2_sdk.message_registry.MessageRegistry.get_msg_file_path","title":"<code>get_msg_file_path(msg_type: str) -&gt; Optional[Path]</code>","text":"<p>Get the path to a .msg file for a given message type. First checks local messages directory, then tries to download from git.</p> <p>Parameters:</p> Name Type Description Default <code>msg_type</code> <code>str</code> <p>ROS2 message type (e.g., \"geometry_msgs/msg/Vector3\")</p> required <p>Returns:</p> Type Description <code>Optional[Path]</code> <p>Path to .msg file or None if not found</p> Source code in <code>zenoh_ros2_sdk/message_registry.py</code> <pre><code>def get_msg_file_path(self, msg_type: str) -&gt; Optional[Path]:\n    \"\"\"\n    Get the path to a .msg file for a given message type.\n    First checks local messages directory, then tries to download from git.\n\n    Args:\n        msg_type: ROS2 message type (e.g., \"geometry_msgs/msg/Vector3\")\n\n    Returns:\n        Path to .msg file or None if not found\n    \"\"\"\n    parts = msg_type.split(\"/\")\n    if len(parts) != 3:\n        return None\n\n    namespace, msg, message_name = parts\n\n    # First, check local messages directory\n    msg_file = self.messages_dir / namespace / msg / f\"{message_name}.msg\"\n    if msg_file.exists():\n        return msg_file\n\n    # If not found locally, try to download from git repository\n    try:\n        # Find which repository contains this package\n        repo_name = get_repository_for_package(namespace)\n        if repo_name:\n            git_path = get_message_file_path(msg_type, repo_name)\n            if git_path and os.path.exists(git_path):\n                return Path(git_path)\n    except ImportError as e:\n        # GitPython not available - log warning but don't fail\n        logger.warning(\n            f\"GitPython not available. Cannot auto-download message file for {msg_type}. \"\n            f\"Install GitPython with 'pip install GitPython' to enable auto-download. \"\n            f\"Error: {e}\"\n        )\n    except Exception as e:\n        # Log the error but don't fail - user can add message manually\n        logger.warning(\n            f\"Failed to auto-download message file for {msg_type} from git repository: {e}. \"\n            f\"You may need to add the message file manually.\"\n        )\n\n    return None\n</code></pre>"},{"location":"api/message_registry/#zenoh_ros2_sdk.message_registry.MessageRegistry.get_srv_file_path","title":"<code>get_srv_file_path(srv_type: str, is_request: bool = True) -&gt; Optional[Path]</code>","text":"<p>Get the path to a .srv file for a given service type. First checks local messages directory, then tries to download from git.</p> <p>Parameters:</p> Name Type Description Default <code>srv_type</code> <code>str</code> <p>ROS2 service type (e.g., \"example_interfaces/srv/AddTwoInts\")</p> required <code>is_request</code> <code>bool</code> <p>If True, return path for request part; if False, for response part</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[Path]</code> <p>Path to .srv file or None if not found</p> Source code in <code>zenoh_ros2_sdk/message_registry.py</code> <pre><code>def get_srv_file_path(self, srv_type: str, is_request: bool = True) -&gt; Optional[Path]:\n    \"\"\"\n    Get the path to a .srv file for a given service type.\n    First checks local messages directory, then tries to download from git.\n\n    Args:\n        srv_type: ROS2 service type (e.g., \"example_interfaces/srv/AddTwoInts\")\n        is_request: If True, return path for request part; if False, for response part\n\n    Returns:\n        Path to .srv file or None if not found\n    \"\"\"\n    parts = srv_type.split(\"/\")\n    if len(parts) != 3:\n        return None\n\n    namespace, srv, service_name = parts\n\n    # First, check local messages directory\n    srv_file = self.messages_dir / namespace / srv / f\"{service_name}.srv\"\n    if srv_file.exists():\n        return srv_file\n\n    # If not found locally, try to download from git repository\n    try:\n        # Find which repository contains this package\n        repo_name = get_repository_for_package(namespace)\n        if repo_name:\n            try:\n                repo_path = clone_to_cache(repo_name)\n                repository = MESSAGE_REPOSITORIES[repo_name]\n\n                # Construct path to service file using shared helper function\n                srv_file_path = construct_message_path(\n                    repo_path, repository, namespace, srv, service_name\n                )\n\n                if os.path.exists(srv_file_path):\n                    return Path(srv_file_path)\n            except Exception as e:\n                logger.warning(\n                    f\"Failed to get service file from cache for {srv_type}: {e}. \"\n                    f\"Trying to clone repository...\"\n                )\n    except ImportError as e:\n        # GitPython not available - log warning but don't fail\n        logger.warning(\n            f\"GitPython not available. Cannot auto-download service file for {srv_type}. \"\n            f\"Install GitPython with 'pip install GitPython' to enable auto-download. \"\n            f\"Error: {e}\"\n        )\n    except Exception as e:\n        # Log the error but don't fail - user can add message manually\n        logger.warning(\n            f\"Failed to auto-download service file for {srv_type} from git repository: {e}. \"\n            f\"You may need to add the service file manually.\"\n        )\n\n    return None\n</code></pre>"},{"location":"api/message_registry/#zenoh_ros2_sdk.message_registry.MessageRegistry.load_service_type","title":"<code>load_service_type(srv_type: str) -&gt; bool</code>","text":"<p>Load a service type (request and response) and their dependencies</p> <p>Parameters:</p> Name Type Description Default <code>srv_type</code> <code>str</code> <p>ROS2 service type (e.g., \"example_interfaces/srv/AddTwoInts\")</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if loaded successfully, False otherwise</p> Source code in <code>zenoh_ros2_sdk/message_registry.py</code> <pre><code>def load_service_type(self, srv_type: str) -&gt; bool:\n    \"\"\"\n    Load a service type (request and response) and their dependencies\n\n    Args:\n        srv_type: ROS2 service type (e.g., \"example_interfaces/srv/AddTwoInts\")\n\n    Returns:\n        True if loaded successfully, False otherwise\n    \"\"\"\n    try:\n        self._load_service_types(srv_type)\n        return True\n    except Exception as e:\n        logger.warning(f\"Failed to load service type {srv_type}: {e}\", exc_info=True)\n        return False\n</code></pre>"},{"location":"api/message_registry/#zenoh_ros2_sdk.message_registry.MessageRegistry.load_message_type","title":"<code>load_message_type(msg_type: str) -&gt; bool</code>","text":"<p>Load a message type and its dependencies</p> <p>Parameters:</p> Name Type Description Default <code>msg_type</code> <code>str</code> <p>ROS2 message type (e.g., \"geometry_msgs/msg/Twist\")</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if loaded successfully, False otherwise</p> Source code in <code>zenoh_ros2_sdk/message_registry.py</code> <pre><code>def load_message_type(self, msg_type: str) -&gt; bool:\n    \"\"\"\n    Load a message type and its dependencies\n\n    Args:\n        msg_type: ROS2 message type (e.g., \"geometry_msgs/msg/Twist\")\n\n    Returns:\n        True if loaded successfully, False otherwise\n    \"\"\"\n    try:\n        self._load_dependencies(msg_type)\n        return True\n    except Exception as e:\n        logger.warning(f\"Failed to load message type {msg_type}: {e}\")\n        return False\n</code></pre>"},{"location":"api/message_registry/#zenoh_ros2_sdk.message_registry.MessageRegistry.get_message_class","title":"<code>get_message_class(msg_type: str) -&gt; Optional[Type[Any]]</code>","text":"<p>Get a message class for a given type (loads if not already loaded)</p> <p>Parameters:</p> Name Type Description Default <code>msg_type</code> <code>str</code> <p>ROS2 message type</p> required <p>Returns:</p> Type Description <code>Optional[Type[Any]]</code> <p>Optional[Type[Any]]: Message class or None if not found</p> Source code in <code>zenoh_ros2_sdk/message_registry.py</code> <pre><code>def get_message_class(self, msg_type: str) -&gt; Optional[Type[Any]]:\n    \"\"\"\n    Get a message class for a given type (loads if not already loaded)\n\n    Args:\n        msg_type: ROS2 message type\n\n    Returns:\n        Optional[Type[Any]]: Message class or None if not found\n    \"\"\"\n    if msg_type not in self._loaded_types:\n        # Service request/response types cannot be loaded from a single .msg file path.\n        # They must be loaded from the parent .srv file.\n        is_service_req_resp = (\n            \"/srv/\" in msg_type and (msg_type.endswith(\"_Request\") or msg_type.endswith(\"_Response\"))\n        )\n        if is_service_req_resp:\n            # example_interfaces/srv/AddTwoInts_Request -&gt; example_interfaces/srv/AddTwoInts\n            if msg_type.endswith(\"_Request\"):\n                base_srv = msg_type[:-8]\n            else:\n                base_srv = msg_type[:-9]\n            if not self.load_service_type(base_srv):\n                return None\n        else:\n            if not self.load_message_type(msg_type):\n                return None\n\n    # Check if we have a mapping to the actual store key (for service types)\n    actual_key = self.session._registered_types.get(msg_type)\n    if actual_key and isinstance(actual_key, str):\n        # actual_key is the store key (may be converted name)\n        return self.session.store.types.get(actual_key)\n\n    # Try direct lookup\n    msg_class = self.session.store.types.get(msg_type)\n    if msg_class is not None:\n        return msg_class\n\n    # Try with /msg/ inserted (for service types: srv/ -&gt; srv/msg/)\n    if '/srv/' in msg_type:\n        converted_name = msg_type.replace('/srv/', '/srv/msg/')\n        return self.session.store.types.get(converted_name)\n\n    return None\n</code></pre>"},{"location":"api/message_registry/#zenoh_ros2_sdk.message_registry.MessageRegistry.is_loaded","title":"<code>is_loaded(msg_type: str) -&gt; bool</code>","text":"<p>Check if a message type is already loaded</p> Source code in <code>zenoh_ros2_sdk/message_registry.py</code> <pre><code>def is_loaded(self, msg_type: str) -&gt; bool:\n    \"\"\"Check if a message type is already loaded\"\"\"\n    return msg_type in self._loaded_types\n</code></pre>"},{"location":"api/message_registry/#zenoh_ros2_sdk.message_registry.get_registry","title":"<code>get_registry(messages_dir: Optional[str] = None) -&gt; MessageRegistry</code>","text":"<p>Get or create the global message registry</p> Source code in <code>zenoh_ros2_sdk/message_registry.py</code> <pre><code>def get_registry(messages_dir: Optional[str] = None) -&gt; MessageRegistry:\n    \"\"\"Get or create the global message registry\"\"\"\n    global _registry\n    if _registry is None:\n        _registry = MessageRegistry(messages_dir)\n    return _registry\n</code></pre>"},{"location":"api/message_registry/#zenoh_ros2_sdk.message_registry.load_message_type","title":"<code>load_message_type(msg_type: str, messages_dir: Optional[str] = None) -&gt; bool</code>","text":"<p>Convenience function to load a message type</p> <p>Parameters:</p> Name Type Description Default <code>msg_type</code> <code>str</code> <p>ROS2 message type (e.g., \"geometry_msgs/msg/Twist\")</p> required <code>messages_dir</code> <code>Optional[str]</code> <p>Optional custom messages directory</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if loaded successfully</p> Source code in <code>zenoh_ros2_sdk/message_registry.py</code> <pre><code>def load_message_type(msg_type: str, messages_dir: Optional[str] = None) -&gt; bool:\n    \"\"\"\n    Convenience function to load a message type\n\n    Args:\n        msg_type: ROS2 message type (e.g., \"geometry_msgs/msg/Twist\")\n        messages_dir: Optional custom messages directory\n\n    Returns:\n        True if loaded successfully\n    \"\"\"\n    registry = get_registry(messages_dir)\n    return registry.load_message_type(msg_type)\n</code></pre>"},{"location":"api/message_registry/#zenoh_ros2_sdk.message_registry.get_message_class","title":"<code>get_message_class(msg_type: str, messages_dir: Optional[str] = None) -&gt; Optional[Type[Any]]</code>","text":"<p>Convenience function to get a message class</p> <p>Parameters:</p> Name Type Description Default <code>msg_type</code> <code>str</code> <p>ROS2 message type</p> required <code>messages_dir</code> <code>Optional[str]</code> <p>Optional custom messages directory</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Type[Any]]</code> <p>Optional[Type[Any]]: Message class or None</p> Source code in <code>zenoh_ros2_sdk/message_registry.py</code> <pre><code>def get_message_class(msg_type: str, messages_dir: Optional[str] = None) -&gt; Optional[Type[Any]]:\n    \"\"\"\n    Convenience function to get a message class\n\n    Args:\n        msg_type: ROS2 message type\n        messages_dir: Optional custom messages directory\n\n    Returns:\n        Optional[Type[Any]]: Message class or None\n    \"\"\"\n    registry = get_registry(messages_dir)\n    return registry.get_message_class(msg_type)\n</code></pre>"},{"location":"api/message_registry/#zenoh_ros2_sdk.message_registry.load_service_type","title":"<code>load_service_type(srv_type: str, messages_dir: Optional[str] = None) -&gt; bool</code>","text":"<p>Convenience function to load a service type</p> <p>Parameters:</p> Name Type Description Default <code>srv_type</code> <code>str</code> <p>ROS2 service type (e.g., \"example_interfaces/srv/AddTwoInts\")</p> required <code>messages_dir</code> <code>Optional[str]</code> <p>Optional custom messages directory</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if loaded successfully</p> Source code in <code>zenoh_ros2_sdk/message_registry.py</code> <pre><code>def load_service_type(srv_type: str, messages_dir: Optional[str] = None) -&gt; bool:\n    \"\"\"\n    Convenience function to load a service type\n\n    Args:\n        srv_type: ROS2 service type (e.g., \"example_interfaces/srv/AddTwoInts\")\n        messages_dir: Optional custom messages directory\n\n    Returns:\n        True if loaded successfully\n    \"\"\"\n    registry = get_registry(messages_dir)\n    return registry.load_service_type(srv_type)\n</code></pre>"},{"location":"api/publisher/","title":"<code>publisher</code>","text":"<p>ROS2Publisher - ROS2 Publisher using Zenoh</p>"},{"location":"api/publisher/#zenoh_ros2_sdk.publisher.ROS2Publisher","title":"<code>ROS2Publisher</code>","text":"<p>ROS2 Publisher using Zenoh.</p> <p>This publisher: - Publishes CDR-encoded messages on a Zenoh key expression:   <code>&lt;domain_id&gt;/&lt;topic&gt;/&lt;dds_type_name&gt;/&lt;type_hash&gt;</code> - Declares <code>@ros2_lv/.../NN</code> and <code>@ros2_lv/.../MP</code> liveliness tokens so it appears in ROS graph tools.</p> Source code in <code>zenoh_ros2_sdk/publisher.py</code> <pre><code>class ROS2Publisher:\n    \"\"\"ROS2 Publisher using Zenoh.\n\n    This publisher:\n    - Publishes CDR-encoded messages on a Zenoh key expression:\n      `&lt;domain_id&gt;/&lt;topic&gt;/&lt;dds_type_name&gt;/&lt;type_hash&gt;`\n    - Declares `@ros2_lv/.../NN` and `@ros2_lv/.../MP` liveliness tokens so it appears in ROS graph tools.\n    \"\"\"\n\n    def __init__(\n        self,\n        topic: str,\n        msg_type: str,\n        msg_definition: Optional[str] = None,\n        node_name: Optional[str] = None,\n        namespace: str = \"/\",\n        domain_id: Optional[int] = None,\n        router_ip: str = \"127.0.0.1\",\n        router_port: int = 7447,\n        type_hash: Optional[str] = None,\n        qos: Optional[object] = None,\n        strict_zenoh_qos: bool = False,\n    ):\n        \"\"\"\n        Create a ROS2 publisher.\n\n        Args:\n            topic: ROS2 topic name (e.g., \"/chatter\")\n            msg_type: ROS2 message type (e.g., \"std_msgs/msg/String\")\n            msg_definition: Message definition text (None to auto-load from registry)\n            node_name: Node name (auto-generated if None)\n            namespace: Node namespace\n            domain_id: ROS domain ID (defaults to ROS_DOMAIN_ID or 0)\n            router_ip: Zenoh router IP\n            router_port: Zenoh router port\n            type_hash: Message type hash (auto-detected if None)\n            qos: QoS used for liveliness discovery tokens and (best-effort) Zenoh publisher settings.\n                Accepts `QosProfile`, an encoded rmw_zenoh QoS string, or `None` for default.\n            strict_zenoh_qos: If True, raise if the Zenoh Python API cannot apply QoS mapping\n                (e.g., `congestion_control` / `express` options).\n\n        Raises:\n            ValueError: If the type hash cannot be computed because message definitions are missing.\n            RuntimeError: If `strict_zenoh_qos=True` and QoS mapping cannot be applied.\n        \"\"\"\n        self.topic = topic\n        self.msg_type = msg_type\n        self.domain_id = resolve_domain_id(domain_id)\n        self.namespace = namespace\n        self.node_name = node_name or f\"zenoh_publisher_{uuid.uuid4().hex[:8]}\"\n        self.strict_zenoh_qos = strict_zenoh_qos\n        # QoS is used both for liveliness tokens and (best-effort) mapping to Zenoh settings.\n        self.qos_profile, self.qos = self._normalize_qos(qos, default=DEFAULT_QOS_PROFILE)\n\n        # Get or create shared session\n        self.session_mgr = ZenohSession.get_instance(router_ip, router_port)\n\n        # Register message type\n        self.msg_class = self.session_mgr.register_message_type(msg_definition, msg_type)\n\n        # Get DDS type name (convert ROS2 type to DDS format)\n        self.dds_type_name = ros2_to_dds_type(msg_type)\n\n        # Get type hash if not provided\n        if type_hash is None:\n            # Get message definition for hash computation\n            # If msg_definition is None, load from registry (same as register_message_type does)\n            # Empty string (\"\") is valid for messages with no fields (like std_msgs/msg/Empty)\n            hash_msg_definition = msg_definition\n            if hash_msg_definition is None:\n                # Load from registry (same logic as register_message_type)\n                try:\n                    registry = get_registry()\n                    msg_file = registry.get_msg_file_path(msg_type)\n                    if msg_file and msg_file.exists():\n                        with open(msg_file, 'r') as f:\n                            hash_msg_definition = f.read()\n                except Exception as e:\n                    # Registry not available or file not found - will raise ValueError below\n                    logger.debug(f\"Could not load message definition from registry for {msg_type}: {e}\")\n                    pass\n\n            # If still None after trying to load, raise error\n            if hash_msg_definition is None:\n                raise ValueError(\n                    f\"Cannot compute type hash for {msg_type}: message definition not provided. \"\n                    \"Please provide msg_definition or ensure the message type is loaded in the registry.\"\n                )\n\n            # Get dependencies from message registry if available (recursively)\n            dependencies = None\n            try:\n                registry = get_registry()\n                # Load all dependencies recursively using shared utility function\n                dependencies = load_dependencies_recursive(msg_type, hash_msg_definition, registry)\n            except Exception as e:\n                # If dependency loading fails, continue without dependencies\n                # Type hash computation will still work, just without nested type info\n                logger.debug(f\"Could not load dependencies for {msg_type}: {e}\")\n                pass\n\n            type_hash = get_type_hash(msg_type, msg_definition=hash_msg_definition, dependencies=dependencies)\n        self.type_hash = type_hash\n\n        # Generate unique GID for this publisher\n        self.publisher_gid = self.session_mgr.generate_gid()\n\n        # Get node and entity IDs\n        self.node_id = self.session_mgr.get_next_node_id()\n        self.entity_id = self.session_mgr.get_next_entity_id()\n\n        # Build keyexpr\n        self.keyexpr = topic_keyexpr(self.domain_id, topic, self.dds_type_name, type_hash)\n\n        # Declare liveliness tokens\n        self._declare_liveliness_tokens()\n\n        # Create publisher\n        self._put_extra_kwargs = {}\n        self.pub = self._declare_zenoh_publisher(self.keyexpr)\n\n        # Message counter\n        self.sequence_number = 0\n        self._closed = False\n\n    def _declare_liveliness_tokens(self):\n        \"\"\"Declare liveliness tokens for ROS2 discovery\"\"\"\n        node = NodeEntity(\n            domain_id=self.domain_id,\n            session_id=self.session_mgr.session_id,\n            node_id=self.node_id,\n            node_name=self.node_name,\n            namespace=self.namespace,\n        )\n        ep = EndpointEntity(\n            node=node,\n            entity_id=self.entity_id,\n            kind=EntityKind.PUBLISHER,\n            name=self.topic,\n            dds_type_name=self.dds_type_name,\n            type_hash=self.type_hash,\n            qos=self.qos,\n            gid=self.publisher_gid,\n        )\n\n        self.node_token = self.session_mgr.liveliness.declare_token(node_liveliness_keyexpr(node))\n        self.publisher_token = self.session_mgr.liveliness.declare_token(endpoint_liveliness_keyexpr(ep))\n\n    @staticmethod\n    def _normalize_qos(qos: Optional[object], *, default: QosProfile) -&gt; tuple[QosProfile, str]:\n        \"\"\"\n        Accept either:\n        - QosProfile\n        - encoded rmw_zenoh QoS string\n        - None (use default)\n        \"\"\"\n        if qos is None:\n            prof = default\n            return prof, prof.encode()\n        if isinstance(qos, QosProfile):\n            return qos, qos.encode()\n        if isinstance(qos, str):\n            # User provided an authoritative encoded QoS string. It must be parseable.\n            return QosProfile.decode(qos), qos\n        return default, default.encode()\n\n    def _declare_zenoh_publisher(self, keyexpr: str):\n        \"\"\"\n        Best-effort QoS -&gt; Zenoh mapping (similar to ros-z):\n        - Reliable =&gt; congestion_control=Block\n        - BestEffort =&gt; congestion_control=Drop\n        - TransientLocal =&gt; express=True\n        - Volatile =&gt; express=False\n\n        Zenoh Python APIs differ across versions; we attempt common kwargs and\n        fall back to passing them at put-time (or not at all).\n        \"\"\"\n        # Resolve Zenoh congestion control enum if available.\n        cc = None\n        try:\n            import zenoh\n            qos_mod = getattr(zenoh, \"qos\", None)\n            cc_enum = getattr(qos_mod, \"CongestionControl\", None) if qos_mod is not None else None\n            if cc_enum is not None:\n                if self.qos_profile.reliability == QosReliability.RELIABLE:\n                    cc = getattr(cc_enum, \"Block\", None) or getattr(cc_enum, \"BLOCK\", None)\n                else:\n                    cc = getattr(cc_enum, \"Drop\", None) or getattr(cc_enum, \"DROP\", None)\n        except Exception:\n            cc = None\n\n        express = self.qos_profile.durability == QosDurability.TRANSIENT_LOCAL\n\n        # Try passing options at declaration time.\n        try:\n            return self.session_mgr.session.declare_publisher(\n                keyexpr,\n                congestion_control=cc,\n                express=express,\n            )\n        except TypeError:\n            msg = (\n                \"Your Zenoh Python API does not support setting publisher QoS options \"\n                \"(congestion_control/express) at declare-time. \"\n                \"QoS token encoding will still be correct, but runtime QoS-&gt;Zenoh mapping may not be applied. \"\n                \"Upgrade zenoh-python or set strict_zenoh_qos=False to continue with best-effort behavior.\"\n            )\n            if self.strict_zenoh_qos:\n                raise RuntimeError(msg)\n            logger.warning(msg)\n\n            # Best-effort: fall back to plain publisher and attempt passing options at put-time.\n            pub = self.session_mgr.session.declare_publisher(keyexpr)\n            if cc is not None:\n                self._put_extra_kwargs[\"congestion_control\"] = cc\n            self._put_extra_kwargs[\"express\"] = express\n            return pub\n\n    def _create_attachment(self, seq_num: int, timestamp_ns: int) -&gt; bytes:\n        \"\"\"Create rmw_zenoh attachment\"\"\"\n        attachment = struct.pack('&lt;Q', seq_num)  # sequence number\n        attachment += struct.pack('&lt;Q', timestamp_ns)  # timestamp\n        attachment += struct.pack('B', len(self.publisher_gid))  # GID length\n        attachment += self.publisher_gid  # GID\n        return attachment\n\n    def publish(self, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Publish a message.\n\n        Args:\n            **kwargs: Message field values (e.g., data=\"hello\" for String message)\n\n        Raises:\n            RuntimeError: If `strict_zenoh_qos=True` and QoS mapping cannot be applied by the Zenoh API.\n        \"\"\"\n        # Create message instance\n        msg = self.msg_class(**kwargs)\n\n        # Serialize to CDR\n        cdr_bytes = bytes(self.session_mgr.store.serialize_cdr(msg, self.msg_type))\n\n        # Create attachment\n        timestamp_ns = int(time.time() * 1e9)\n        attachment = self._create_attachment(self.sequence_number, timestamp_ns)\n\n        # Publish (best-effort QoS passthrough for Zenoh implementations that accept it)\n        try:\n            self.pub.put(\n                cdr_bytes,\n                encoding=Encoding(\"application/cdr\"),\n                attachment=attachment,\n                **self._put_extra_kwargs,\n            )\n        except TypeError:\n            # Zenoh Python API version doesn't accept extra kwargs on put()\n            if self._put_extra_kwargs:\n                msg = (\n                    \"Your Zenoh Python API does not accept QoS-related kwargs on publisher.put(). \"\n                    f\"Unable to apply requested QoS-&gt;Zenoh mapping at runtime. kwargs={list(self._put_extra_kwargs.keys())}\"\n                )\n                if self.strict_zenoh_qos:\n                    raise RuntimeError(msg)\n                logger.warning(msg)\n            self.pub.put(cdr_bytes, encoding=Encoding(\"application/cdr\"), attachment=attachment)\n        self.sequence_number += 1\n\n    def close(self):\n        \"\"\"\n        Close the publisher and undeclare tokens.\n\n        This method is idempotent - it's safe to call multiple times.\n        \"\"\"\n        # Check if already closed\n        if hasattr(self, '_closed') and self._closed:\n            return\n\n        try:\n            if hasattr(self, 'node_token') and self.node_token is not None:\n                self.node_token.undeclare()\n            if hasattr(self, 'publisher_token') and self.publisher_token is not None:\n                self.publisher_token.undeclare()\n            # Optionally undeclare the publisher itself (though tokens are the main cleanup)\n            if hasattr(self, 'pub') and self.pub is not None:\n                if hasattr(self.pub, 'undeclare'):\n                    self.pub.undeclare()\n                self.pub = None\n            self._closed = True\n        except (AttributeError, RuntimeError) as e:\n            # AttributeError: token doesn't exist\n            # RuntimeError: Zenoh runtime errors\n            logger.debug(f\"Error during publisher cleanup for topic {self.topic}: {e}\")\n            self._closed = True\n        except Exception as e:\n            # Catch any other unexpected exceptions during cleanup\n            logger.warning(f\"Unexpected error during publisher cleanup for topic {self.topic}: {e}\")\n            self._closed = True\n</code></pre>"},{"location":"api/publisher/#zenoh_ros2_sdk.publisher.ROS2Publisher.publish","title":"<code>publish(**kwargs: Any) -&gt; None</code>","text":"<p>Publish a message.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Message field values (e.g., data=\"hello\" for String message)</p> <code>{}</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If <code>strict_zenoh_qos=True</code> and QoS mapping cannot be applied by the Zenoh API.</p> Source code in <code>zenoh_ros2_sdk/publisher.py</code> <pre><code>def publish(self, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Publish a message.\n\n    Args:\n        **kwargs: Message field values (e.g., data=\"hello\" for String message)\n\n    Raises:\n        RuntimeError: If `strict_zenoh_qos=True` and QoS mapping cannot be applied by the Zenoh API.\n    \"\"\"\n    # Create message instance\n    msg = self.msg_class(**kwargs)\n\n    # Serialize to CDR\n    cdr_bytes = bytes(self.session_mgr.store.serialize_cdr(msg, self.msg_type))\n\n    # Create attachment\n    timestamp_ns = int(time.time() * 1e9)\n    attachment = self._create_attachment(self.sequence_number, timestamp_ns)\n\n    # Publish (best-effort QoS passthrough for Zenoh implementations that accept it)\n    try:\n        self.pub.put(\n            cdr_bytes,\n            encoding=Encoding(\"application/cdr\"),\n            attachment=attachment,\n            **self._put_extra_kwargs,\n        )\n    except TypeError:\n        # Zenoh Python API version doesn't accept extra kwargs on put()\n        if self._put_extra_kwargs:\n            msg = (\n                \"Your Zenoh Python API does not accept QoS-related kwargs on publisher.put(). \"\n                f\"Unable to apply requested QoS-&gt;Zenoh mapping at runtime. kwargs={list(self._put_extra_kwargs.keys())}\"\n            )\n            if self.strict_zenoh_qos:\n                raise RuntimeError(msg)\n            logger.warning(msg)\n        self.pub.put(cdr_bytes, encoding=Encoding(\"application/cdr\"), attachment=attachment)\n    self.sequence_number += 1\n</code></pre>"},{"location":"api/publisher/#zenoh_ros2_sdk.publisher.ROS2Publisher.close","title":"<code>close()</code>","text":"<p>Close the publisher and undeclare tokens.</p> <p>This method is idempotent - it's safe to call multiple times.</p> Source code in <code>zenoh_ros2_sdk/publisher.py</code> <pre><code>def close(self):\n    \"\"\"\n    Close the publisher and undeclare tokens.\n\n    This method is idempotent - it's safe to call multiple times.\n    \"\"\"\n    # Check if already closed\n    if hasattr(self, '_closed') and self._closed:\n        return\n\n    try:\n        if hasattr(self, 'node_token') and self.node_token is not None:\n            self.node_token.undeclare()\n        if hasattr(self, 'publisher_token') and self.publisher_token is not None:\n            self.publisher_token.undeclare()\n        # Optionally undeclare the publisher itself (though tokens are the main cleanup)\n        if hasattr(self, 'pub') and self.pub is not None:\n            if hasattr(self.pub, 'undeclare'):\n                self.pub.undeclare()\n            self.pub = None\n        self._closed = True\n    except (AttributeError, RuntimeError) as e:\n        # AttributeError: token doesn't exist\n        # RuntimeError: Zenoh runtime errors\n        logger.debug(f\"Error during publisher cleanup for topic {self.topic}: {e}\")\n        self._closed = True\n    except Exception as e:\n        # Catch any other unexpected exceptions during cleanup\n        logger.warning(f\"Unexpected error during publisher cleanup for topic {self.topic}: {e}\")\n        self._closed = True\n</code></pre>"},{"location":"api/qos/","title":"<code>qos</code>","text":"<p>QoS model and encoding compatible with rmw_zenoh_cpp / ros-z.</p> <p>rmw_zenoh encodes QoS into liveliness tokens as a compact string:</p> <p>::,:   :: <p>Empty fields mean \"use default\" (as in rmw_zenoh / ros-z).</p>"},{"location":"api/qos/#zenoh_ros2_sdk.qos.QosProfile","title":"<code>QosProfile</code>","text":"<p>QoS profile compatible with rmw_zenoh / ros-z QoS token encoding.</p> Notes <ul> <li>This SDK primarily uses QoS to populate <code>@ros2_lv/.../&lt;qos&gt;</code> liveliness tokens.</li> <li>Some QoS fields may not have a runtime effect unless the underlying Zenoh API supports it.</li> <li><code>encode()</code>/<code>decode()</code> implement the same compact format used by <code>rmw_zenoh_cpp</code> and <code>ros-z</code>.</li> </ul> Source code in <code>zenoh_ros2_sdk/qos.py</code> <pre><code>@slotted_dataclass(frozen=True)\nclass QosProfile:\n    \"\"\"QoS profile compatible with rmw_zenoh / ros-z QoS token encoding.\n\n    Notes:\n        - This SDK primarily uses QoS to populate `@ros2_lv/.../&lt;qos&gt;` liveliness tokens.\n        - Some QoS fields may not have a runtime effect unless the underlying Zenoh API supports it.\n        - `encode()`/`decode()` implement the same compact format used by `rmw_zenoh_cpp` and `ros-z`.\n    \"\"\"\n    reliability: QosReliability = QosReliability.RELIABLE\n    durability: QosDurability = QosDurability.VOLATILE\n    history_kind: QosHistoryKind = QosHistoryKind.KEEP_LAST\n    history_depth: int = 10\n    deadline: Duration = DURATION_INFINITE\n    lifespan: Duration = DURATION_INFINITE\n    liveliness: QosLiveliness = QosLiveliness.AUTOMATIC\n    liveliness_lease_duration: Duration = DURATION_INFINITE\n\n    def encode(self, *, default: Optional[\"QosProfile\"] = None) -&gt; str:\n        \"\"\"\n        Encode into the rmw_zenoh QoS token format (compatible with ros-z).\n\n        If `default` is provided, fields equal to `default` are elided (empty).\n        \"\"\"\n        default = default or QosProfile()\n\n        reliability = \"\" if self.reliability == default.reliability else str(self.reliability.value)\n        durability = \"\" if self.durability == default.durability else str(self.durability.value)\n\n        # History: &lt;kind&gt;,&lt;depth&gt;\n        if self.history_kind == QosHistoryKind.KEEP_LAST:\n            if (self.history_kind == default.history_kind) and (self.history_depth == default.history_depth):\n                history = f\",{self.history_depth}\"\n            elif self.history_kind == default.history_kind:\n                history = f\",{self.history_depth}\"\n            else:\n                history = f\"{self.history_kind.value},{self.history_depth}\"\n        else:\n            # KEEP_ALL has no depth\n            history = f\"{self.history_kind.value},\"\n\n        def _encode_dur(d: Duration, d_default: Duration) -&gt; str:\n            if d == d_default:\n                return \",\"\n            return f\"{d.sec},{d.nsec}\"\n\n        deadline = _encode_dur(self.deadline, default.deadline)\n        lifespan = _encode_dur(self.lifespan, default.lifespan)\n\n        if (self.liveliness == default.liveliness) and (self.liveliness_lease_duration == default.liveliness_lease_duration):\n            liveliness = \",,\"\n        else:\n            liveliness = f\"{self.liveliness.value},{self.liveliness_lease_duration.sec},{self.liveliness_lease_duration.nsec}\"\n\n        return f\"{reliability}:{durability}:{history}:{deadline}:{lifespan}:{liveliness}\"\n\n    @staticmethod\n    def decode(encoded: str) -&gt; \"QosProfile\":\n        \"\"\"\n        Decode from the rmw_zenoh QoS token format.\n\n        This is intentionally lenient and treats empty fields as defaults.\n        \"\"\"\n        default = QosProfile()\n        parts = (encoded or \"\").split(\":\")\n        if len(parts) &lt; 6:\n            raise ValueError(f\"Incomplete QoS string (expected 6 fields): {encoded!r}\")\n\n        def _rel(s: str) -&gt; QosReliability:\n            if s in (\"\", \"0\", \"1\"):\n                return default.reliability\n            if s == \"2\":\n                return QosReliability.BEST_EFFORT\n            raise ValueError(f\"Invalid reliability: {s!r}\")\n\n        def _dur(s: str) -&gt; QosDurability:\n            if s in (\"\", \"0\", \"2\"):\n                return default.durability\n            if s == \"1\":\n                return QosDurability.TRANSIENT_LOCAL\n            raise ValueError(f\"Invalid durability: {s!r}\")\n\n        def _history(s: str) -&gt; Tuple[QosHistoryKind, int]:\n            if s in (\"\", \",\"):\n                return default.history_kind, default.history_depth\n            kind_s, depth_s = (s.split(\",\", 1) + [\"\"])[:2]\n            # kind may be empty =&gt; default keep_last\n            if kind_s in (\"\", \"0\", \"1\"):\n                kind = QosHistoryKind.KEEP_LAST\n                depth = int(depth_s) if depth_s != \"\" else default.history_depth\n                return kind, depth\n            if kind_s == \"2\":\n                return QosHistoryKind.KEEP_ALL, 0\n            raise ValueError(f\"Invalid history: {s!r}\")\n\n        def _dur2(s: str, d_default: Duration) -&gt; Duration:\n            if s in (\"\", \",\"):\n                return d_default\n            sec_s, nsec_s = (s.split(\",\", 1) + [\"\"])[:2]\n            sec = int(sec_s) if sec_s != \"\" else d_default.sec\n            nsec = int(nsec_s) if nsec_s != \"\" else d_default.nsec\n            return Duration(sec=sec, nsec=nsec)\n\n        def _liveliness(s: str) -&gt; Tuple[QosLiveliness, Duration]:\n            if s in (\"\", \",,\"):\n                return default.liveliness, default.liveliness_lease_duration\n            kind_s, sec_s, nsec_s = (s.split(\",\", 2) + [\"\", \"\"])[:3]\n            if kind_s in (\"\", \"0\", \"1\"):\n                kind = QosLiveliness.AUTOMATIC\n            elif kind_s == \"2\":\n                kind = QosLiveliness.MANUAL_BY_NODE\n            elif kind_s == \"3\":\n                kind = QosLiveliness.MANUAL_BY_TOPIC\n            else:\n                kind = default.liveliness\n            sec = int(sec_s) if sec_s != \"\" else default.liveliness_lease_duration.sec\n            nsec = int(nsec_s) if nsec_s != \"\" else default.liveliness_lease_duration.nsec\n            return kind, Duration(sec=sec, nsec=nsec)\n\n        reliability = _rel(parts[0])\n        durability = _dur(parts[1])\n        history_kind, history_depth = _history(parts[2])\n        deadline = _dur2(parts[3], default.deadline)\n        lifespan = _dur2(parts[4], default.lifespan)\n        liveliness, liveliness_lease_duration = _liveliness(parts[5])\n\n        return QosProfile(\n            reliability=reliability,\n            durability=durability,\n            history_kind=history_kind,\n            history_depth=history_depth,\n            deadline=deadline,\n            lifespan=lifespan,\n            liveliness=liveliness,\n            liveliness_lease_duration=liveliness_lease_duration,\n        )\n</code></pre>"},{"location":"api/qos/#zenoh_ros2_sdk.qos.QosProfile.encode","title":"<code>encode(*, default: Optional['QosProfile'] = None) -&gt; str</code>","text":"<p>Encode into the rmw_zenoh QoS token format (compatible with ros-z).</p> <p>If <code>default</code> is provided, fields equal to <code>default</code> are elided (empty).</p> Source code in <code>zenoh_ros2_sdk/qos.py</code> <pre><code>def encode(self, *, default: Optional[\"QosProfile\"] = None) -&gt; str:\n    \"\"\"\n    Encode into the rmw_zenoh QoS token format (compatible with ros-z).\n\n    If `default` is provided, fields equal to `default` are elided (empty).\n    \"\"\"\n    default = default or QosProfile()\n\n    reliability = \"\" if self.reliability == default.reliability else str(self.reliability.value)\n    durability = \"\" if self.durability == default.durability else str(self.durability.value)\n\n    # History: &lt;kind&gt;,&lt;depth&gt;\n    if self.history_kind == QosHistoryKind.KEEP_LAST:\n        if (self.history_kind == default.history_kind) and (self.history_depth == default.history_depth):\n            history = f\",{self.history_depth}\"\n        elif self.history_kind == default.history_kind:\n            history = f\",{self.history_depth}\"\n        else:\n            history = f\"{self.history_kind.value},{self.history_depth}\"\n    else:\n        # KEEP_ALL has no depth\n        history = f\"{self.history_kind.value},\"\n\n    def _encode_dur(d: Duration, d_default: Duration) -&gt; str:\n        if d == d_default:\n            return \",\"\n        return f\"{d.sec},{d.nsec}\"\n\n    deadline = _encode_dur(self.deadline, default.deadline)\n    lifespan = _encode_dur(self.lifespan, default.lifespan)\n\n    if (self.liveliness == default.liveliness) and (self.liveliness_lease_duration == default.liveliness_lease_duration):\n        liveliness = \",,\"\n    else:\n        liveliness = f\"{self.liveliness.value},{self.liveliness_lease_duration.sec},{self.liveliness_lease_duration.nsec}\"\n\n    return f\"{reliability}:{durability}:{history}:{deadline}:{lifespan}:{liveliness}\"\n</code></pre>"},{"location":"api/qos/#zenoh_ros2_sdk.qos.QosProfile.decode","title":"<code>decode(encoded: str) -&gt; 'QosProfile'</code>  <code>staticmethod</code>","text":"<p>Decode from the rmw_zenoh QoS token format.</p> <p>This is intentionally lenient and treats empty fields as defaults.</p> Source code in <code>zenoh_ros2_sdk/qos.py</code> <pre><code>@staticmethod\ndef decode(encoded: str) -&gt; \"QosProfile\":\n    \"\"\"\n    Decode from the rmw_zenoh QoS token format.\n\n    This is intentionally lenient and treats empty fields as defaults.\n    \"\"\"\n    default = QosProfile()\n    parts = (encoded or \"\").split(\":\")\n    if len(parts) &lt; 6:\n        raise ValueError(f\"Incomplete QoS string (expected 6 fields): {encoded!r}\")\n\n    def _rel(s: str) -&gt; QosReliability:\n        if s in (\"\", \"0\", \"1\"):\n            return default.reliability\n        if s == \"2\":\n            return QosReliability.BEST_EFFORT\n        raise ValueError(f\"Invalid reliability: {s!r}\")\n\n    def _dur(s: str) -&gt; QosDurability:\n        if s in (\"\", \"0\", \"2\"):\n            return default.durability\n        if s == \"1\":\n            return QosDurability.TRANSIENT_LOCAL\n        raise ValueError(f\"Invalid durability: {s!r}\")\n\n    def _history(s: str) -&gt; Tuple[QosHistoryKind, int]:\n        if s in (\"\", \",\"):\n            return default.history_kind, default.history_depth\n        kind_s, depth_s = (s.split(\",\", 1) + [\"\"])[:2]\n        # kind may be empty =&gt; default keep_last\n        if kind_s in (\"\", \"0\", \"1\"):\n            kind = QosHistoryKind.KEEP_LAST\n            depth = int(depth_s) if depth_s != \"\" else default.history_depth\n            return kind, depth\n        if kind_s == \"2\":\n            return QosHistoryKind.KEEP_ALL, 0\n        raise ValueError(f\"Invalid history: {s!r}\")\n\n    def _dur2(s: str, d_default: Duration) -&gt; Duration:\n        if s in (\"\", \",\"):\n            return d_default\n        sec_s, nsec_s = (s.split(\",\", 1) + [\"\"])[:2]\n        sec = int(sec_s) if sec_s != \"\" else d_default.sec\n        nsec = int(nsec_s) if nsec_s != \"\" else d_default.nsec\n        return Duration(sec=sec, nsec=nsec)\n\n    def _liveliness(s: str) -&gt; Tuple[QosLiveliness, Duration]:\n        if s in (\"\", \",,\"):\n            return default.liveliness, default.liveliness_lease_duration\n        kind_s, sec_s, nsec_s = (s.split(\",\", 2) + [\"\", \"\"])[:3]\n        if kind_s in (\"\", \"0\", \"1\"):\n            kind = QosLiveliness.AUTOMATIC\n        elif kind_s == \"2\":\n            kind = QosLiveliness.MANUAL_BY_NODE\n        elif kind_s == \"3\":\n            kind = QosLiveliness.MANUAL_BY_TOPIC\n        else:\n            kind = default.liveliness\n        sec = int(sec_s) if sec_s != \"\" else default.liveliness_lease_duration.sec\n        nsec = int(nsec_s) if nsec_s != \"\" else default.liveliness_lease_duration.nsec\n        return kind, Duration(sec=sec, nsec=nsec)\n\n    reliability = _rel(parts[0])\n    durability = _dur(parts[1])\n    history_kind, history_depth = _history(parts[2])\n    deadline = _dur2(parts[3], default.deadline)\n    lifespan = _dur2(parts[4], default.lifespan)\n    liveliness, liveliness_lease_duration = _liveliness(parts[5])\n\n    return QosProfile(\n        reliability=reliability,\n        durability=durability,\n        history_kind=history_kind,\n        history_depth=history_depth,\n        deadline=deadline,\n        lifespan=lifespan,\n        liveliness=liveliness,\n        liveliness_lease_duration=liveliness_lease_duration,\n    )\n</code></pre>"},{"location":"api/service_client/","title":"<code>service_client</code>","text":"<p>ROS2ServiceClient - ROS2 Service Client using Zenoh</p>"},{"location":"api/service_client/#zenoh_ros2_sdk.service_client.ROS2ServiceClient","title":"<code>ROS2ServiceClient</code>","text":"<p>ROS2 Service Client using Zenoh - sends requests and receives responses</p> Source code in <code>zenoh_ros2_sdk/service_client.py</code> <pre><code>class ROS2ServiceClient:\n    \"\"\"ROS2 Service Client using Zenoh - sends requests and receives responses\"\"\"\n\n    def __init__(\n        self,\n        service_name: str,\n        srv_type: str,\n        request_definition: Optional[str] = None,\n        response_definition: Optional[str] = None,\n        node_name: Optional[str] = None,\n        namespace: str = \"/\",\n        domain_id: Optional[int] = None,\n        router_ip: str = \"127.0.0.1\",\n        router_port: int = 7447,\n        type_hash: Optional[str] = None,\n        timeout: float = 10.0,\n        qos: Optional[object] = None,\n    ):\n        \"\"\"\n        Create a ROS2 service client.\n\n        This client sends requests using Zenoh queries and expects:\n        - `Reply.ok` to be a Zenoh `Sample` with `.payload.to_bytes()`\n        - `Reply.err` to be a Zenoh `ReplyError` with `.payload.to_bytes()`\n\n        Args:\n            service_name: ROS2 service name (e.g., \"/add_two_ints\")\n            srv_type: ROS2 service type (e.g., \"example_interfaces/srv/AddTwoInts\")\n            request_definition: Request message definition text (None to auto-load)\n            response_definition: Response message definition text (None to auto-load)\n            node_name: Node name (auto-generated if None)\n            namespace: Node namespace\n            domain_id: ROS domain ID (defaults to ROS_DOMAIN_ID or 0)\n            router_ip: Zenoh router IP\n            router_port: Zenoh router port\n            type_hash: Service type hash (auto-detected if None)\n            timeout: Timeout for service calls in seconds (default: 10.0)\n            qos: QoS used for liveliness discovery tokens.\n                Accepts `QosProfile`, an encoded rmw_zenoh QoS string, or `None` for default.\n\n        Raises:\n            ValueError: If `srv_type` format is invalid.\n            RuntimeError: If service definitions cannot be loaded to compute the type hash.\n        \"\"\"\n        self.service_name = service_name\n        self.srv_type = srv_type\n        self.domain_id = resolve_domain_id(domain_id)\n        self.namespace = namespace\n        self.node_name = node_name or f\"zenoh_service_client_{uuid.uuid4().hex[:8]}\"\n        self.timeout = timeout\n        _, self.qos = self._normalize_qos(qos, default=DEFAULT_QOS_PROFILE, fallback=DEFAULT_QOS_PROFILE.encode())\n\n        # Get or create shared session\n        self.session_mgr = ZenohSession.get_instance(router_ip, router_port)\n\n        # Parse service type to get request and response types\n        # Service types are like \"example_interfaces/srv/AddTwoInts\"\n        # Request type: \"example_interfaces/srv/AddTwoInts_Request\"\n        # Response type: \"example_interfaces/srv/AddTwoInts_Response\"\n        parts = srv_type.split(\"/\")\n        if len(parts) != 3:\n            raise ValueError(f\"Invalid service type format: {srv_type}. Expected format: namespace/srv/ServiceName\")\n\n        namespace_part, srv, service_name_part = parts\n        self.request_type = f\"{namespace_part}/srv/{service_name_part}_Request\"\n        self.response_type = f\"{namespace_part}/srv/{service_name_part}_Response\"\n\n        # Register message types (will auto-load from registry if definitions are empty)\n        # register_message_type will automatically detect service request/response types\n        # and load the service type if needed (like publisher/subscriber do for messages)\n        self.request_msg_class = self.session_mgr.register_message_type(request_definition, self.request_type)\n        self.response_msg_class = self.session_mgr.register_message_type(response_definition, self.response_type)\n\n        # Get the actual store type names (may be converted for service types)\n        # rosbags converts srv/TypeName to srv/msg/TypeName\n        self.request_store_type = self.session_mgr._registered_types.get(self.request_type, self.request_type)\n        self.response_store_type = self.session_mgr._registered_types.get(self.response_type, self.response_type)\n\n        # Get DDS type name (remove _Request suffix for service type)\n        # Service type name should be without Request_ or Response_ suffix\n        service_dds_type = ros2_to_dds_type(srv_type)\n        # Remove the last underscore and Request/Response suffix if present\n        if service_dds_type.endswith(\"_Request_\"):\n            service_dds_type = service_dds_type[:-9]  # Remove \"_Request_\"\n        elif service_dds_type.endswith(\"_Response_\"):\n            service_dds_type = service_dds_type[:-10]  # Remove \"_Response_\"\n\n        self.dds_type_name = service_dds_type\n\n        # Get type hash if not provided\n        if type_hash is None:\n            # Get message definitions for hash computation\n            hash_request_def = request_definition\n            hash_response_def = response_definition\n\n            if not hash_request_def or not hash_response_def:\n                try:\n                    registry = get_registry()\n\n                    # get_srv_file_path returns the same .srv file for both request and response\n                    # We need to read it and split by '---' to get request and response parts\n                    if not hash_request_def or not hash_response_def:\n                        srv_file = registry.get_srv_file_path(srv_type, is_request=True)\n                        if srv_file and srv_file.exists():\n                            with open(srv_file, 'r') as f:\n                                srv_content = f.read()\n\n                            # Split by '---' separator\n                            # ROS2 .srv files MUST have a '---' separator between request and response\n                            parts = srv_content.split('---', 1)\n                            if len(parts) &lt; 2:\n                                raise ValueError(\n                                    f\"Invalid service definition file for {srv_type}: \"\n                                    \"missing '---' separator between request and response. \"\n                                    f\"File content: {repr(srv_content[:100])}\"\n                                )\n\n                            if not hash_request_def:\n                                hash_request_def = parts[0].strip()\n                            if not hash_response_def:\n                                hash_response_def = parts[1].strip()\n\n                            # Validate that we got both parts\n                            if not hash_request_def:\n                                raise ValueError(\n                                    f\"Service definition file for {srv_type} has empty request definition\"\n                                )\n                            if not hash_response_def:\n                                raise ValueError(\n                                    f\"Service definition file for {srv_type} has empty response definition\"\n                                )\n                except Exception as e:\n                    # Re-raise with more context - don't silently swallow errors\n                    raise RuntimeError(\n                        f\"Failed to load service definitions from registry for {srv_type}: {e}\"\n                    ) from e\n\n            if not hash_request_def or not hash_response_def:\n                raise ValueError(\n                    f\"Cannot compute type hash for {srv_type}: service definitions not provided. \"\n                    \"Please provide request_definition and response_definition or ensure the service type is loaded in the registry.\"\n                )\n\n            # Get dependencies recursively\n            dependencies = None\n            try:\n                registry = get_registry()\n                # Load dependencies for both request and response using shared utility function\n                req_deps = load_dependencies_recursive(self.request_type, hash_request_def, registry)\n                resp_deps = load_dependencies_recursive(self.response_type, hash_response_def, registry)\n                dependencies = {**req_deps, **resp_deps}\n            except Exception as e:\n                logger.debug(f\"Could not load dependencies for {srv_type}: {e}\")\n\n            # For services, compute hash from the service type itself (not just request)\n            # Services are represented as a type with request_message, response_message, and event_message fields\n            type_hash = compute_service_type_hash(\n                self.srv_type,\n                request_definition=hash_request_def,\n                response_definition=hash_response_def,\n                dependencies=dependencies\n            )\n\n        self.type_hash = type_hash\n\n        # Generate unique GID for this client\n        self.client_gid = self.session_mgr.generate_gid()\n\n        # Get node and entity IDs\n        self.node_id = self.session_mgr.get_next_node_id()\n        self.entity_id = self.session_mgr.get_next_entity_id()\n\n        # Build keyexpr for service (used for queries)\n        # Format: domain_id/service_name/dds_type_name/type_hash\n        self.keyexpr = topic_keyexpr(self.domain_id, service_name, self.dds_type_name, type_hash)\n\n        # Declare liveliness tokens\n        self._declare_liveliness_tokens()\n\n        # Create querier for sending requests\n        # Zenoh Python API: declare_querier(key_expr, *, target=None, consolidation=None, timeout=None, ...)\n        querier_ke = zenoh.KeyExpr(self.keyexpr)\n\n        self.querier = self.session_mgr.session.declare_querier(\n            querier_ke,\n            target=zenoh.QueryTarget.ALL_COMPLETE,\n            timeout=int(self.timeout * 1000),\n            consolidation=zenoh.ConsolidationMode.NONE\n        )\n\n        # Sequence tracking\n        self.sequence_number = 1\n        self._lock = threading.Lock()\n        self._closed = False\n\n    @staticmethod\n    def _normalize_qos(\n        qos: Optional[object],\n        *,\n        default: QosProfile,\n        fallback: str,\n    ) -&gt; tuple[QosProfile, str]:\n        if qos is None:\n            return default, fallback\n        if isinstance(qos, QosProfile):\n            return qos, qos.encode()\n        if isinstance(qos, str):\n            return QosProfile.decode(qos), qos\n        return default, fallback\n\n    def _declare_liveliness_tokens(self):\n        \"\"\"Declare liveliness tokens for ROS2 discovery\"\"\"\n        node = NodeEntity(\n            domain_id=self.domain_id,\n            session_id=self.session_mgr.session_id,\n            node_id=self.node_id,\n            node_name=self.node_name,\n            namespace=self.namespace,\n        )\n        ep = EndpointEntity(\n            node=node,\n            entity_id=self.entity_id,\n            kind=EntityKind.CLIENT,\n            name=self.service_name,\n            dds_type_name=self.dds_type_name,\n            type_hash=self.type_hash,\n            qos=self.qos,\n            gid=self.client_gid,\n        )\n\n        self.node_token = self.session_mgr.liveliness.declare_token(node_liveliness_keyexpr(node))\n        self.client_token = self.session_mgr.liveliness.declare_token(endpoint_liveliness_keyexpr(ep))\n\n    def _create_attachment(self, seq_num: int, timestamp_ns: int) -&gt; bytes:\n        \"\"\"Create rmw_zenoh attachment for service request\"\"\"\n        return Attachment(sequence_id=seq_num, timestamp_ns=timestamp_ns, gid=self.client_gid).to_bytes()\n\n    def call(self, **kwargs: Any) -&gt; Optional[object]:\n        \"\"\"\n        Call the service synchronously\n\n        Args:\n            **kwargs: Request field values\n\n        Returns:\n            Response message object or None if timeout/error\n        \"\"\"\n        # Create request message instance\n        request_msg = self.request_msg_class(**kwargs)\n\n        # Serialize to CDR (use store type name which may be converted)\n        cdr_bytes = bytes(self.session_mgr.store.serialize_cdr(request_msg, self.request_store_type))\n\n        # Create attachment\n        timestamp_ns = int(time.time() * 1e9)\n        sequence_id = self.sequence_number\n        self.sequence_number += 1\n        attachment = self._create_attachment(sequence_id, timestamp_ns)\n\n        # Response event for synchronization\n        response_event = threading.Event()\n        response_data = {\"response\": None, \"error\": None}\n\n        def reply_callback(reply: zenoh.Reply):\n            \"\"\"Callback for receiving service response\"\"\"\n            try:\n                # Verified in-container:\n                # - reply.ok is a builtins.Sample, with ok.payload: ZBytes\n                # - reply.err is a builtins.ReplyError, with err.payload: ZBytes\n                if reply.err is not None:\n                    err = reply.err\n                    payload = getattr(err, \"payload\", None)\n                    if payload is None or not hasattr(payload, \"to_bytes\"):\n                        raise TypeError(\n                            \"Unexpected ReplyError shape. Expected err.payload with to_bytes(). \"\n                            f\"err_type={type(err)} payload_type={type(payload)}\"\n                        )\n                    error_msg = payload.to_bytes().decode(\"utf-8\", errors=\"ignore\")\n                    logger.error(f\"Service call failed: {error_msg}\")\n                    response_data[\"error\"] = error_msg\n                    response_event.set()\n                    return\n\n                if reply.ok is not None:\n                    ok = reply.ok\n                    payload = getattr(ok, \"payload\", None)\n                    if payload is None or not hasattr(payload, \"to_bytes\"):\n                        raise TypeError(\n                            \"Unexpected Reply ok shape. Expected ok.payload with to_bytes(). \"\n                            f\"ok_type={type(ok)} payload_type={type(payload)}\"\n                        )\n                    cdr_bytes = payload.to_bytes()\n\n                    # Deserialize response (use store type name which may be converted)\n                    response_msg = self.session_mgr.store.deserialize_cdr(cdr_bytes, self.response_store_type)\n                    response_data[\"response\"] = response_msg\n                    response_event.set()\n                else:\n                    logger.error(\"Reply has neither ok nor err\")\n                    response_data[\"error\"] = \"Invalid reply format\"\n                    response_event.set()\n            except Exception as e:\n                logger.error(f\"Error processing service response: {e}\", exc_info=True)\n                response_data[\"error\"] = str(e)\n                response_event.set()\n\n        # Send request using querier\n        # Zenoh Python API: get(handler=None, *, parameters=None, payload=None, encoding=None, attachment=None, ...)\n        self.querier.get(\n            reply_callback,\n            parameters=\"\",\n            payload=zenoh.ZBytes(cdr_bytes),\n            encoding=Encoding(\"application/cdr\"),\n            attachment=zenoh.ZBytes(attachment)\n        )\n\n        # querier.get() doesn't return a result code in Python API - it's fire-and-forget\n        # Errors will be reported in the reply_callback\n\n        # Wait for response with timeout\n        if response_event.wait(timeout=self.timeout):\n            if response_data[\"error\"]:\n                logger.error(f\"Service call error: {response_data['error']}\")\n                return None\n            return response_data[\"response\"]\n        else:\n            logger.warning(f\"Service call timed out after {self.timeout} seconds\")\n            return None\n\n    def call_async(self, callback: Callable, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Call the service asynchronously\n\n        Args:\n            callback: Callback function(response_msg) called when response is received\n            **kwargs: Request field values\n        \"\"\"\n        # Create request message instance\n        request_msg = self.request_msg_class(**kwargs)\n\n        # Serialize to CDR (use store type name which may be converted)\n        cdr_bytes = bytes(self.session_mgr.store.serialize_cdr(request_msg, self.request_store_type))\n\n        # Create attachment\n        timestamp_ns = int(time.time() * 1e9)\n        sequence_id = self.sequence_number\n        self.sequence_number += 1\n        attachment = self._create_attachment(sequence_id, timestamp_ns)\n\n        def reply_callback(reply: zenoh.Reply):\n            \"\"\"Callback for receiving service response\"\"\"\n            try:\n                if reply.err is not None:\n                    err = reply.err\n                    payload = getattr(err, \"payload\", None)\n                    if payload is None or not hasattr(payload, \"to_bytes\"):\n                        raise TypeError(\n                            \"Unexpected ReplyError shape. Expected err.payload with to_bytes(). \"\n                            f\"err_type={type(err)} payload_type={type(payload)}\"\n                        )\n                    error_msg = payload.to_bytes().decode(\"utf-8\", errors=\"ignore\")\n                    logger.error(f\"Async service call failed: {error_msg}\")\n                    callback(None)\n                    return\n\n                if reply.ok is not None:\n                    ok = reply.ok\n                    payload = getattr(ok, \"payload\", None)\n                    if payload is None or not hasattr(payload, \"to_bytes\"):\n                        raise TypeError(\n                            \"Unexpected Reply ok shape. Expected ok.payload with to_bytes(). \"\n                            f\"ok_type={type(ok)} payload_type={type(payload)}\"\n                        )\n                    cdr_bytes = payload.to_bytes()\n\n                    # Deserialize response (use store type name which may be converted)\n                    response_msg = self.session_mgr.store.deserialize_cdr(cdr_bytes, self.response_store_type)\n                    callback(response_msg)\n                else:\n                    logger.error(\"Reply has neither ok nor err\")\n                    callback(None)\n            except Exception as e:\n                logger.error(f\"Error processing async service response: {e}\", exc_info=True)\n                callback(None)\n\n        # Send request using querier\n        # Zenoh Python API: get(handler=None, *, parameters=None, payload=None, encoding=None, attachment=None, ...)\n        # querier.get() doesn't return a result code in Python API - it's fire-and-forget\n        # Errors will be reported in the reply_callback\n        self.querier.get(\n            reply_callback,\n            parameters=\"\",\n            payload=zenoh.ZBytes(cdr_bytes),\n            encoding=Encoding(\"application/cdr\"),\n            attachment=zenoh.ZBytes(attachment)\n        )\n\n    def close(self):\n        \"\"\"\n        Close the service client and undeclare tokens.\n\n        This method is idempotent - it's safe to call multiple times.\n        \"\"\"\n        if hasattr(self, '_closed') and self._closed:\n            return\n\n        try:\n            if hasattr(self, 'node_token') and self.node_token is not None:\n                self.node_token.undeclare()\n            if hasattr(self, 'client_token') and self.client_token is not None:\n                self.client_token.undeclare()\n            if hasattr(self, 'querier') and self.querier is not None:\n                if hasattr(self.querier, 'undeclare'):\n                    self.querier.undeclare()\n                self.querier = None\n            self._closed = True\n        except (AttributeError, RuntimeError) as e:\n            logger.debug(f\"Error during service client cleanup for service {self.service_name}: {e}\")\n            self._closed = True\n        except Exception as e:\n            logger.warning(f\"Unexpected error during service client cleanup for service {self.service_name}: {e}\")\n            self._closed = True\n</code></pre>"},{"location":"api/service_client/#zenoh_ros2_sdk.service_client.ROS2ServiceClient.call","title":"<code>call(**kwargs: Any) -&gt; Optional[object]</code>","text":"<p>Call the service synchronously</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>Request field values</p> <code>{}</code> <p>Returns:</p> Type Description <code>Optional[object]</code> <p>Response message object or None if timeout/error</p> Source code in <code>zenoh_ros2_sdk/service_client.py</code> <pre><code>def call(self, **kwargs: Any) -&gt; Optional[object]:\n    \"\"\"\n    Call the service synchronously\n\n    Args:\n        **kwargs: Request field values\n\n    Returns:\n        Response message object or None if timeout/error\n    \"\"\"\n    # Create request message instance\n    request_msg = self.request_msg_class(**kwargs)\n\n    # Serialize to CDR (use store type name which may be converted)\n    cdr_bytes = bytes(self.session_mgr.store.serialize_cdr(request_msg, self.request_store_type))\n\n    # Create attachment\n    timestamp_ns = int(time.time() * 1e9)\n    sequence_id = self.sequence_number\n    self.sequence_number += 1\n    attachment = self._create_attachment(sequence_id, timestamp_ns)\n\n    # Response event for synchronization\n    response_event = threading.Event()\n    response_data = {\"response\": None, \"error\": None}\n\n    def reply_callback(reply: zenoh.Reply):\n        \"\"\"Callback for receiving service response\"\"\"\n        try:\n            # Verified in-container:\n            # - reply.ok is a builtins.Sample, with ok.payload: ZBytes\n            # - reply.err is a builtins.ReplyError, with err.payload: ZBytes\n            if reply.err is not None:\n                err = reply.err\n                payload = getattr(err, \"payload\", None)\n                if payload is None or not hasattr(payload, \"to_bytes\"):\n                    raise TypeError(\n                        \"Unexpected ReplyError shape. Expected err.payload with to_bytes(). \"\n                        f\"err_type={type(err)} payload_type={type(payload)}\"\n                    )\n                error_msg = payload.to_bytes().decode(\"utf-8\", errors=\"ignore\")\n                logger.error(f\"Service call failed: {error_msg}\")\n                response_data[\"error\"] = error_msg\n                response_event.set()\n                return\n\n            if reply.ok is not None:\n                ok = reply.ok\n                payload = getattr(ok, \"payload\", None)\n                if payload is None or not hasattr(payload, \"to_bytes\"):\n                    raise TypeError(\n                        \"Unexpected Reply ok shape. Expected ok.payload with to_bytes(). \"\n                        f\"ok_type={type(ok)} payload_type={type(payload)}\"\n                    )\n                cdr_bytes = payload.to_bytes()\n\n                # Deserialize response (use store type name which may be converted)\n                response_msg = self.session_mgr.store.deserialize_cdr(cdr_bytes, self.response_store_type)\n                response_data[\"response\"] = response_msg\n                response_event.set()\n            else:\n                logger.error(\"Reply has neither ok nor err\")\n                response_data[\"error\"] = \"Invalid reply format\"\n                response_event.set()\n        except Exception as e:\n            logger.error(f\"Error processing service response: {e}\", exc_info=True)\n            response_data[\"error\"] = str(e)\n            response_event.set()\n\n    # Send request using querier\n    # Zenoh Python API: get(handler=None, *, parameters=None, payload=None, encoding=None, attachment=None, ...)\n    self.querier.get(\n        reply_callback,\n        parameters=\"\",\n        payload=zenoh.ZBytes(cdr_bytes),\n        encoding=Encoding(\"application/cdr\"),\n        attachment=zenoh.ZBytes(attachment)\n    )\n\n    # querier.get() doesn't return a result code in Python API - it's fire-and-forget\n    # Errors will be reported in the reply_callback\n\n    # Wait for response with timeout\n    if response_event.wait(timeout=self.timeout):\n        if response_data[\"error\"]:\n            logger.error(f\"Service call error: {response_data['error']}\")\n            return None\n        return response_data[\"response\"]\n    else:\n        logger.warning(f\"Service call timed out after {self.timeout} seconds\")\n        return None\n</code></pre>"},{"location":"api/service_client/#zenoh_ros2_sdk.service_client.ROS2ServiceClient.call_async","title":"<code>call_async(callback: Callable, **kwargs: Any) -&gt; None</code>","text":"<p>Call the service asynchronously</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable</code> <p>Callback function(response_msg) called when response is received</p> required <code>**kwargs</code> <code>Any</code> <p>Request field values</p> <code>{}</code> Source code in <code>zenoh_ros2_sdk/service_client.py</code> <pre><code>def call_async(self, callback: Callable, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Call the service asynchronously\n\n    Args:\n        callback: Callback function(response_msg) called when response is received\n        **kwargs: Request field values\n    \"\"\"\n    # Create request message instance\n    request_msg = self.request_msg_class(**kwargs)\n\n    # Serialize to CDR (use store type name which may be converted)\n    cdr_bytes = bytes(self.session_mgr.store.serialize_cdr(request_msg, self.request_store_type))\n\n    # Create attachment\n    timestamp_ns = int(time.time() * 1e9)\n    sequence_id = self.sequence_number\n    self.sequence_number += 1\n    attachment = self._create_attachment(sequence_id, timestamp_ns)\n\n    def reply_callback(reply: zenoh.Reply):\n        \"\"\"Callback for receiving service response\"\"\"\n        try:\n            if reply.err is not None:\n                err = reply.err\n                payload = getattr(err, \"payload\", None)\n                if payload is None or not hasattr(payload, \"to_bytes\"):\n                    raise TypeError(\n                        \"Unexpected ReplyError shape. Expected err.payload with to_bytes(). \"\n                        f\"err_type={type(err)} payload_type={type(payload)}\"\n                    )\n                error_msg = payload.to_bytes().decode(\"utf-8\", errors=\"ignore\")\n                logger.error(f\"Async service call failed: {error_msg}\")\n                callback(None)\n                return\n\n            if reply.ok is not None:\n                ok = reply.ok\n                payload = getattr(ok, \"payload\", None)\n                if payload is None or not hasattr(payload, \"to_bytes\"):\n                    raise TypeError(\n                        \"Unexpected Reply ok shape. Expected ok.payload with to_bytes(). \"\n                        f\"ok_type={type(ok)} payload_type={type(payload)}\"\n                    )\n                cdr_bytes = payload.to_bytes()\n\n                # Deserialize response (use store type name which may be converted)\n                response_msg = self.session_mgr.store.deserialize_cdr(cdr_bytes, self.response_store_type)\n                callback(response_msg)\n            else:\n                logger.error(\"Reply has neither ok nor err\")\n                callback(None)\n        except Exception as e:\n            logger.error(f\"Error processing async service response: {e}\", exc_info=True)\n            callback(None)\n\n    # Send request using querier\n    # Zenoh Python API: get(handler=None, *, parameters=None, payload=None, encoding=None, attachment=None, ...)\n    # querier.get() doesn't return a result code in Python API - it's fire-and-forget\n    # Errors will be reported in the reply_callback\n    self.querier.get(\n        reply_callback,\n        parameters=\"\",\n        payload=zenoh.ZBytes(cdr_bytes),\n        encoding=Encoding(\"application/cdr\"),\n        attachment=zenoh.ZBytes(attachment)\n    )\n</code></pre>"},{"location":"api/service_client/#zenoh_ros2_sdk.service_client.ROS2ServiceClient.close","title":"<code>close()</code>","text":"<p>Close the service client and undeclare tokens.</p> <p>This method is idempotent - it's safe to call multiple times.</p> Source code in <code>zenoh_ros2_sdk/service_client.py</code> <pre><code>def close(self):\n    \"\"\"\n    Close the service client and undeclare tokens.\n\n    This method is idempotent - it's safe to call multiple times.\n    \"\"\"\n    if hasattr(self, '_closed') and self._closed:\n        return\n\n    try:\n        if hasattr(self, 'node_token') and self.node_token is not None:\n            self.node_token.undeclare()\n        if hasattr(self, 'client_token') and self.client_token is not None:\n            self.client_token.undeclare()\n        if hasattr(self, 'querier') and self.querier is not None:\n            if hasattr(self.querier, 'undeclare'):\n                self.querier.undeclare()\n            self.querier = None\n        self._closed = True\n    except (AttributeError, RuntimeError) as e:\n        logger.debug(f\"Error during service client cleanup for service {self.service_name}: {e}\")\n        self._closed = True\n    except Exception as e:\n        logger.warning(f\"Unexpected error during service client cleanup for service {self.service_name}: {e}\")\n        self._closed = True\n</code></pre>"},{"location":"api/service_server/","title":"<code>service_server</code>","text":"<p>ROS2ServiceServer - ROS2 Service Server using Zenoh</p>"},{"location":"api/service_server/#zenoh_ros2_sdk.service_server.ServiceRequestKey","title":"<code>ServiceRequestKey</code>","text":"<p>Correlation key for service requests, aligned with ros-z QueryKey and rmw_zenoh.</p> Source code in <code>zenoh_ros2_sdk/service_server.py</code> <pre><code>@slotted_dataclass(frozen=True)\nclass ServiceRequestKey:\n    \"\"\"\n    Correlation key for service requests, aligned with ros-z QueryKey and rmw_zenoh.\n    \"\"\"\n\n    sequence_id: int\n    gid: bytes\n</code></pre>"},{"location":"api/service_server/#zenoh_ros2_sdk.service_server.ROS2ServiceServer","title":"<code>ROS2ServiceServer</code>","text":"<p>ROS2 Service Server using Zenoh - receives requests and sends responses</p> Source code in <code>zenoh_ros2_sdk/service_server.py</code> <pre><code>class ROS2ServiceServer:\n    \"\"\"ROS2 Service Server using Zenoh - receives requests and sends responses\"\"\"\n\n    def __init__(\n        self,\n        service_name: str,\n        srv_type: str,\n        callback: Optional[Callable] = None,\n        request_definition: Optional[str] = None,\n        response_definition: Optional[str] = None,\n        node_name: Optional[str] = None,\n        namespace: str = \"/\",\n        domain_id: Optional[int] = None,\n        router_ip: str = \"127.0.0.1\",\n        router_port: int = 7447,\n        type_hash: Optional[str] = None,\n        qos: Optional[object] = None,\n        mode: str = \"callback\",\n    ):\n        \"\"\"\n        Create a ROS2 service server.\n\n        Modes:\n            - `mode=\"callback\"` (default): `callback(request_msg) -&gt; response_msg` is called and the server replies immediately.\n            - `mode=\"queue\"`: requests are queued; user calls `take_request()` then `send_response()` with the returned key.\n\n        Attachments:\n            Service requests **must** include an attachment (sequence_id + gid). The server uses this to:\n            - correlate requests/responses\n            - reply with an attachment that contains the same (sequence_id, gid) plus a new timestamp\n\n        Args:\n            service_name: ROS2 service name (e.g., \"/add_two_ints\")\n            srv_type: ROS2 service type (e.g., \"example_interfaces/srv/AddTwoInts\")\n            callback: Callback function(request_msg) -&gt; response_msg called when request is received\n            request_definition: Request message definition text (None to auto-load)\n            response_definition: Response message definition text (None to auto-load)\n            node_name: Node name (auto-generated if None)\n            namespace: Node namespace\n            domain_id: ROS domain ID (defaults to ROS_DOMAIN_ID or 0)\n            router_ip: Zenoh router IP\n            router_port: Zenoh router port\n            type_hash: Service type hash (auto-detected if None)\n            qos: QoS used for liveliness discovery tokens.\n                Accepts `QosProfile`, an encoded rmw_zenoh QoS string, or `None` for default.\n            mode: `callback` or `queue`.\n\n        Raises:\n            ValueError: If `srv_type` format is invalid or if mode/callback is inconsistent.\n            RuntimeError: If called queue-only APIs while not in queue mode.\n        \"\"\"\n        if mode not in (\"callback\", \"queue\"):\n            raise ValueError(f\"Invalid mode: {mode}. Expected 'callback' or 'queue'\")\n        if mode == \"callback\" and callback is None:\n            raise ValueError(\"callback must be provided when mode='callback'\")\n\n        self.service_name = service_name\n        self.srv_type = srv_type\n        self.callback = callback\n        self.mode = mode\n        self.domain_id = resolve_domain_id(domain_id)\n        self.namespace = namespace\n        self.node_name = node_name or f\"zenoh_service_server_{uuid.uuid4().hex[:8]}\"\n        _, self.qos = self._normalize_qos(qos, default=DEFAULT_QOS_PROFILE, fallback=DEFAULT_QOS_PROFILE.encode())\n\n        # Get or create shared session\n        self.session_mgr = ZenohSession.get_instance(router_ip, router_port)\n\n        # Parse service type to get request and response types\n        parts = srv_type.split(\"/\")\n        if len(parts) != 3:\n            raise ValueError(f\"Invalid service type format: {srv_type}. Expected format: namespace/srv/ServiceName\")\n\n        namespace_part, srv, service_name_part = parts\n        self.request_type = f\"{namespace_part}/srv/{service_name_part}_Request\"\n        self.response_type = f\"{namespace_part}/srv/{service_name_part}_Response\"\n\n        # Register message types (will auto-load from registry if definitions are empty)\n        # register_message_type will automatically detect service request/response types\n        # and load the service type if needed (like publisher/subscriber do for messages)\n        self.request_msg_class = self.session_mgr.register_message_type(request_definition, self.request_type)\n        self.response_msg_class = self.session_mgr.register_message_type(response_definition, self.response_type)\n\n        # Get the actual store type names (may be converted for service types)\n        # rosbags converts srv/TypeName to srv/msg/TypeName\n        self.request_store_type = self.session_mgr._registered_types.get(self.request_type, self.request_type)\n        self.response_store_type = self.session_mgr._registered_types.get(self.response_type, self.response_type)\n\n        # Get DDS type name (remove _Response suffix for service type)\n        service_dds_type = ros2_to_dds_type(srv_type)\n        if service_dds_type.endswith(\"_Request_\"):\n            service_dds_type = service_dds_type[:-9]\n        elif service_dds_type.endswith(\"_Response_\"):\n            service_dds_type = service_dds_type[:-10]\n\n        self.dds_type_name = service_dds_type\n\n        # Get type hash if not provided\n        if type_hash is None:\n            # Get message definitions for hash computation\n            hash_request_def = request_definition\n            hash_response_def = response_definition\n\n            if not hash_request_def or not hash_response_def:\n                try:\n                    registry = get_registry()\n\n                    # get_srv_file_path returns the same .srv file for both request and response\n                    # We need to read it and split by '---' to get request and response parts\n                    if not hash_request_def or not hash_response_def:\n                        srv_file = registry.get_srv_file_path(srv_type, is_request=True)\n                        if srv_file and srv_file.exists():\n                            with open(srv_file, 'r') as f:\n                                srv_content = f.read()\n\n                            # Split by '---' separator\n                            # ROS2 .srv files MUST have a '---' separator between request and response\n                            parts = srv_content.split('---', 1)\n                            if len(parts) &lt; 2:\n                                raise ValueError(\n                                    f\"Invalid service definition file for {srv_type}: \"\n                                    \"missing '---' separator between request and response. \"\n                                    f\"File content: {repr(srv_content[:100])}\"\n                                )\n\n                            if not hash_request_def:\n                                hash_request_def = parts[0].strip()\n                            if not hash_response_def:\n                                hash_response_def = parts[1].strip()\n\n                            # Validate that we got both parts\n                            if not hash_request_def:\n                                raise ValueError(\n                                    f\"Service definition file for {srv_type} has empty request definition\"\n                                )\n                            if not hash_response_def:\n                                raise ValueError(\n                                    f\"Service definition file for {srv_type} has empty response definition\"\n                                )\n                except Exception as e:\n                    # Re-raise with more context - don't silently swallow errors\n                    raise RuntimeError(\n                        f\"Failed to load service definitions from registry for {srv_type}: {e}\"\n                    ) from e\n\n            if not hash_request_def or not hash_response_def:\n                raise ValueError(\n                    f\"Cannot compute type hash for {srv_type}: service definitions not provided. \"\n                    \"Please provide request_definition and response_definition or ensure the service type is loaded in the registry.\"\n                )\n\n            # Get dependencies recursively\n            dependencies = None\n            try:\n                registry = get_registry()\n                # Load dependencies for both request and response using shared utility function\n                req_deps = load_dependencies_recursive(self.request_type, hash_request_def, registry)\n                resp_deps = load_dependencies_recursive(self.response_type, hash_response_def, registry)\n                dependencies = {**req_deps, **resp_deps}\n            except Exception as e:\n                logger.debug(f\"Could not load dependencies for {srv_type}: {e}\")\n\n            # For services, compute hash from the service type itself (not just request)\n            # Services are represented as a type with request_message, response_message, and event_message fields\n            type_hash = compute_service_type_hash(\n                self.srv_type,\n                request_definition=hash_request_def,\n                response_definition=hash_response_def,\n                dependencies=dependencies\n            )\n\n        self.type_hash = type_hash\n\n        # Generate unique GID for this server\n        self.server_gid = self.session_mgr.generate_gid()\n\n        # Get node and entity IDs\n        self.node_id = self.session_mgr.get_next_node_id()\n        self.entity_id = self.session_mgr.get_next_entity_id()\n\n        # Build keyexpr for service (used for queryable)\n        self.keyexpr = topic_keyexpr(self.domain_id, service_name, self.dds_type_name, type_hash)\n        logger.info(f\"Service keyexpr: {self.keyexpr}\")\n        logger.info(f\"Service type hash: {type_hash}\")\n\n        # Declare liveliness tokens\n        self._declare_liveliness_tokens()\n\n        # Create queryable for receiving requests\n        queryable_ke = zenoh.KeyExpr(self.keyexpr)\n        logger.info(f\"Declaring queryable on keyexpr: {self.keyexpr}\")\n\n        # Zenoh Python API: declare_queryable(key_expr, handler=None, *, complete=None, allowed_origin=None)\n        self.queryable = self.session_mgr.session.declare_queryable(\n            queryable_ke,\n            self._query_handler,\n            complete=True\n        )\n        logger.info(f\"Queryable declared successfully on: {self.keyexpr}\")\n\n        # Queue-mode state (ros-z style)\n        self._lock = threading.Lock()\n        self._cv = threading.Condition(self._lock)\n        self._queue: deque[Tuple[ServiceRequestKey, object]] = deque()\n        self._pending_queries: Dict[ServiceRequestKey, zenoh.Query] = {}\n\n        self._closed = False\n\n    @staticmethod\n    def _normalize_qos(\n        qos: Optional[object],\n        *,\n        default: QosProfile,\n        fallback: str,\n    ) -&gt; tuple[QosProfile, str]:\n        if qos is None:\n            return default, fallback\n        if isinstance(qos, QosProfile):\n            return qos, qos.encode()\n        if isinstance(qos, str):\n            return QosProfile.decode(qos), qos\n        return default, fallback\n\n    def _declare_liveliness_tokens(self):\n        \"\"\"Declare liveliness tokens for ROS2 discovery\"\"\"\n        node = NodeEntity(\n            domain_id=self.domain_id,\n            session_id=self.session_mgr.session_id,\n            node_id=self.node_id,\n            node_name=self.node_name,\n            namespace=self.namespace,\n        )\n        ep = EndpointEntity(\n            node=node,\n            entity_id=self.entity_id,\n            kind=EntityKind.SERVICE,\n            name=self.service_name,\n            dds_type_name=self.dds_type_name,\n            type_hash=self.type_hash,\n            qos=self.qos,\n            gid=self.server_gid,\n        )\n\n        self.node_token = self.session_mgr.liveliness.declare_token(node_liveliness_keyexpr(node))\n        self.service_token = self.session_mgr.liveliness.declare_token(endpoint_liveliness_keyexpr(ep))\n\n    def _create_response_attachment(self, request_seq_num: int, request_gid: bytes) -&gt; bytes:\n        \"\"\"Create rmw_zenoh attachment for service response (seq + new_ts + same_gid).\"\"\"\n        timestamp_ns = int(time.time() * 1e9)\n        return Attachment(sequence_id=request_seq_num, timestamp_ns=timestamp_ns, gid=request_gid).to_bytes()\n\n    def take_request(self, timeout: Optional[float] = None) -&gt; Tuple[ServiceRequestKey, object]:\n        \"\"\"\n        Queue-mode API (ros-z style): block until a request is available, then return (key, request_msg).\n        \"\"\"\n        if self.mode != \"queue\":\n            raise RuntimeError(\"take_request() is only available when mode='queue'\")\n        with self._cv:\n            if timeout is None:\n                while not self._queue:\n                    self._cv.wait()\n            else:\n                end = time.time() + timeout\n                while not self._queue:\n                    remaining = end - time.time()\n                    if remaining &lt;= 0:\n                        raise TimeoutError(\"Timed out waiting for service request\")\n                    self._cv.wait(timeout=remaining)\n            key, msg = self._queue.popleft()\n            return key, msg\n\n    def send_response(self, key: ServiceRequestKey, response_msg: object) -&gt; None:\n        \"\"\"\n        Queue-mode API (ros-z style): reply to a previously taken request using its correlation key.\n        \"\"\"\n        if self.mode != \"queue\":\n            raise RuntimeError(\"send_response() is only available when mode='queue'\")\n        with self._lock:\n            query = self._pending_queries.pop(key, None)\n        if query is None:\n            raise KeyError(f\"No pending query found for key={key}\")\n\n        response_cdr_bytes = bytes(self.session_mgr.store.serialize_cdr(response_msg, self.response_store_type))\n        response_attachment = self._create_response_attachment(key.sequence_id, key.gid)\n        query.reply(\n            zenoh.KeyExpr(self.keyexpr),\n            zenoh.ZBytes(response_cdr_bytes),\n            encoding=Encoding(\"application/cdr\"),\n            attachment=zenoh.ZBytes(response_attachment),\n        )\n\n    def _query_handler(self, query: zenoh.Query):\n        \"\"\"Handle incoming service request query\"\"\"\n        # Keep logs at debug to avoid spamming in production.\n        query_key = str(query.key_expr) if hasattr(query, 'key_expr') else 'unknown'\n        logger.debug(f\"Service request received. Query keyexpr: {query_key}, Expected: {self.keyexpr}\")\n        try:\n            # Verified in-container: query.payload is a ZBytes and supports to_bytes().\n            payload = getattr(query, \"payload\", None)\n            if payload is None or not hasattr(payload, \"to_bytes\"):\n                error_msg = (\n                    \"Service request has unsupported payload shape. Expected query.payload with to_bytes(). \"\n                    f\"payload_type={type(payload)}\"\n                )\n                logger.error(error_msg)\n                query.reply_err(zenoh.ZBytes(error_msg.encode()))\n                return\n\n            cdr_bytes = payload.to_bytes()\n            if not cdr_bytes:\n                error_msg = \"Service request payload is empty\"\n                logger.error(error_msg)\n                query.reply_err(zenoh.ZBytes(error_msg.encode()))\n                return\n\n            # Get attachment from query (required for response)\n            # Following ros-z and rmw_zenoh pattern: response attachment includes\n            # sequence number and GID from request, plus new timestamp\n            # According to rmw_zenoh design, attachment is REQUIRED for service requests\n            attachment = getattr(query, \"attachment\", None)\n            if attachment is None or not hasattr(attachment, \"to_bytes\"):\n                error_msg = \"Service request attachment is None - attachment is required for service requests\"\n                logger.error(error_msg)\n                query.reply_err(zenoh.ZBytes(error_msg.encode()))\n                return\n\n            # Parse attachment (strict)\n            try:\n                att = Attachment.from_bytes(attachment.to_bytes())\n            except Exception as e:\n                error_msg = f\"Failed to parse service request attachment: {e}\"\n                logger.error(error_msg, exc_info=True)\n                query.reply_err(zenoh.ZBytes(error_msg.encode()))\n                return\n\n            key = ServiceRequestKey(sequence_id=int(att.sequence_id), gid=bytes(att.gid))\n\n            # Deserialize request (use store type name which may be converted)\n            request_msg = self.session_mgr.store.deserialize_cdr(cdr_bytes, self.request_store_type)\n\n            if self.mode == \"queue\":\n                # Store query for later response (ros-z style).\n                with self._cv:\n                    if key in self._pending_queries:\n                        query.reply_err(zenoh.ZBytes(b\"Duplicate service request key\"))\n                        return\n\n                    # Enforce queue depth via QoS (KeepAll =&gt; unbounded)\n                    qos_profile = QosProfile.decode(self.qos)\n                    if qos_profile.history_kind != qos_profile.history_kind.KEEP_ALL and qos_profile.history_depth &gt; 0:\n                        while len(self._queue) &gt;= qos_profile.history_depth:\n                            dropped_key, _ = self._queue.popleft()\n                            self._pending_queries.pop(dropped_key, None)\n                            logger.warning(\n                                \"Service request queue depth reached; dropping oldest request. \"\n                                f\"service={self.service_name} depth={qos_profile.history_depth}\"\n                            )\n\n                    self._pending_queries[key] = query\n                    self._queue.append((key, request_msg))\n                    self._cv.notify()\n                return\n\n            # callback mode (default): call user callback and reply immediately\n            try:\n                response_msg = self.callback(request_msg)  # type: ignore[misc]\n                if response_msg is None:\n                    raise RuntimeError(\"Service callback returned None\")\n\n                response_cdr_bytes = bytes(self.session_mgr.store.serialize_cdr(response_msg, self.response_store_type))\n                response_attachment = self._create_response_attachment(key.sequence_id, key.gid)\n\n                query.reply(\n                    zenoh.KeyExpr(self.keyexpr),\n                    zenoh.ZBytes(response_cdr_bytes),\n                    encoding=Encoding(\"application/cdr\"),\n                    attachment=zenoh.ZBytes(response_attachment),\n                )\n            except Exception as e:\n                logger.error(f\"Error in service callback: {e}\", exc_info=True)\n                query.reply_err(zenoh.ZBytes(f\"Service callback error: {str(e)}\".encode()))\n\n        except Exception as e:\n            logger.error(f\"Error handling service request: {e}\", exc_info=True)\n            try:\n                query.reply_err(zenoh.ZBytes(f\"Service handler error: {str(e)}\".encode()))\n            except Exception as reply_error:\n                logger.debug(f\"Failed to send error reply: {reply_error}\")\n\n    def close(self):\n        \"\"\"\n        Close the service server and undeclare tokens.\n\n        This method is idempotent - it's safe to call multiple times.\n        \"\"\"\n        if hasattr(self, '_closed') and self._closed:\n            return\n\n        try:\n            if hasattr(self, 'node_token') and self.node_token is not None:\n                self.node_token.undeclare()\n            if hasattr(self, 'service_token') and self.service_token is not None:\n                self.service_token.undeclare()\n            if hasattr(self, 'queryable') and self.queryable is not None:\n                if hasattr(self.queryable, 'undeclare'):\n                    self.queryable.undeclare()\n                self.queryable = None\n            self._closed = True\n        except (AttributeError, RuntimeError) as e:\n            logger.debug(f\"Error during service server cleanup for service {self.service_name}: {e}\")\n            self._closed = True\n        except Exception as e:\n            logger.warning(f\"Unexpected error during service server cleanup for service {self.service_name}: {e}\")\n            self._closed = True\n</code></pre>"},{"location":"api/service_server/#zenoh_ros2_sdk.service_server.ROS2ServiceServer.take_request","title":"<code>take_request(timeout: Optional[float] = None) -&gt; Tuple[ServiceRequestKey, object]</code>","text":"<p>Queue-mode API (ros-z style): block until a request is available, then return (key, request_msg).</p> Source code in <code>zenoh_ros2_sdk/service_server.py</code> <pre><code>def take_request(self, timeout: Optional[float] = None) -&gt; Tuple[ServiceRequestKey, object]:\n    \"\"\"\n    Queue-mode API (ros-z style): block until a request is available, then return (key, request_msg).\n    \"\"\"\n    if self.mode != \"queue\":\n        raise RuntimeError(\"take_request() is only available when mode='queue'\")\n    with self._cv:\n        if timeout is None:\n            while not self._queue:\n                self._cv.wait()\n        else:\n            end = time.time() + timeout\n            while not self._queue:\n                remaining = end - time.time()\n                if remaining &lt;= 0:\n                    raise TimeoutError(\"Timed out waiting for service request\")\n                self._cv.wait(timeout=remaining)\n        key, msg = self._queue.popleft()\n        return key, msg\n</code></pre>"},{"location":"api/service_server/#zenoh_ros2_sdk.service_server.ROS2ServiceServer.send_response","title":"<code>send_response(key: ServiceRequestKey, response_msg: object) -&gt; None</code>","text":"<p>Queue-mode API (ros-z style): reply to a previously taken request using its correlation key.</p> Source code in <code>zenoh_ros2_sdk/service_server.py</code> <pre><code>def send_response(self, key: ServiceRequestKey, response_msg: object) -&gt; None:\n    \"\"\"\n    Queue-mode API (ros-z style): reply to a previously taken request using its correlation key.\n    \"\"\"\n    if self.mode != \"queue\":\n        raise RuntimeError(\"send_response() is only available when mode='queue'\")\n    with self._lock:\n        query = self._pending_queries.pop(key, None)\n    if query is None:\n        raise KeyError(f\"No pending query found for key={key}\")\n\n    response_cdr_bytes = bytes(self.session_mgr.store.serialize_cdr(response_msg, self.response_store_type))\n    response_attachment = self._create_response_attachment(key.sequence_id, key.gid)\n    query.reply(\n        zenoh.KeyExpr(self.keyexpr),\n        zenoh.ZBytes(response_cdr_bytes),\n        encoding=Encoding(\"application/cdr\"),\n        attachment=zenoh.ZBytes(response_attachment),\n    )\n</code></pre>"},{"location":"api/service_server/#zenoh_ros2_sdk.service_server.ROS2ServiceServer.close","title":"<code>close()</code>","text":"<p>Close the service server and undeclare tokens.</p> <p>This method is idempotent - it's safe to call multiple times.</p> Source code in <code>zenoh_ros2_sdk/service_server.py</code> <pre><code>def close(self):\n    \"\"\"\n    Close the service server and undeclare tokens.\n\n    This method is idempotent - it's safe to call multiple times.\n    \"\"\"\n    if hasattr(self, '_closed') and self._closed:\n        return\n\n    try:\n        if hasattr(self, 'node_token') and self.node_token is not None:\n            self.node_token.undeclare()\n        if hasattr(self, 'service_token') and self.service_token is not None:\n            self.service_token.undeclare()\n        if hasattr(self, 'queryable') and self.queryable is not None:\n            if hasattr(self.queryable, 'undeclare'):\n                self.queryable.undeclare()\n            self.queryable = None\n        self._closed = True\n    except (AttributeError, RuntimeError) as e:\n        logger.debug(f\"Error during service server cleanup for service {self.service_name}: {e}\")\n        self._closed = True\n    except Exception as e:\n        logger.warning(f\"Unexpected error during service server cleanup for service {self.service_name}: {e}\")\n        self._closed = True\n</code></pre>"},{"location":"api/session/","title":"<code>session</code>","text":"<p>ZenohSession - Manages shared Zenoh session and type store</p>"},{"location":"api/session/#zenoh_ros2_sdk.session.ZenohSession","title":"<code>ZenohSession</code>","text":"<p>Manages a shared Zenoh session and type store</p> Source code in <code>zenoh_ros2_sdk/session.py</code> <pre><code>class ZenohSession:\n    \"\"\"Manages a shared Zenoh session and type store\"\"\"\n    _instance = None\n    _lock = threading.Lock()\n\n    def __init__(self, router_ip: str = \"127.0.0.1\", router_port: int = 7447):\n        self.router_ip = router_ip\n        self.router_port = router_port\n        self.conf = zenoh.Config()\n        # Defaults (can be overridden via ZENOH_CONFIG_OVERRIDE)\n        self.conf.insert_json5(\n            \"connect/endpoints\", f'[\"tcp/{router_ip}:{router_port}\"]'\n        )\n\n        override = os.environ.get(\"ZENOH_CONFIG_OVERRIDE\", \"\").strip()\n        if override:\n            _apply_zenoh_config_override(self.conf, override)\n\n        self.session = zenoh.open(self.conf)\n        self.store = get_typestore(Stores.EMPTY)\n        self._registered_types = {}\n        self._node_counter = 0\n        self._entity_counter = 0\n        self._lock = threading.Lock()\n\n        # Get session ID\n        session_info = self.session.info\n        self.session_id = str(session_info.zid())\n        self.liveliness = self.session.liveliness()\n\n    @classmethod\n    def get_instance(cls, router_ip: str = \"127.0.0.1\", router_port: int = 7447):\n        \"\"\"Get or create singleton instance\"\"\"\n        if cls._instance is None:\n            with cls._lock:\n                if cls._instance is None:\n                    cls._instance = cls(router_ip, router_port)\n        return cls._instance\n\n    def register_message_type(self, msg_definition: Optional[str], ros2_type_name: str):\n        \"\"\"Register a ROS2 message type\"\"\"\n        # Check if already registered and in store\n        if ros2_type_name in self._registered_types:\n            # Get the actual store key (may be converted name for service types)\n            actual_key = self._registered_types[ros2_type_name]\n            if isinstance(actual_key, str):\n                # actual_key is the store key\n                msg_class = self.store.types.get(actual_key)\n                if msg_class is not None:\n                    return msg_class\n            else:\n                # actual_key is the types dict (old format), try direct lookup\n                msg_class = self.store.types.get(ros2_type_name)\n                if msg_class is not None:\n                    return msg_class\n                # Try converted name for service types\n                if '/srv/' in ros2_type_name:\n                    converted_name = ros2_type_name.replace('/srv/', '/srv/msg/')\n                    msg_class = self.store.types.get(converted_name)\n                    if msg_class is not None:\n                        # Update mapping to use converted name\n                        self._registered_types[ros2_type_name] = converted_name\n                        return msg_class\n\n            # If in _registered_types but not in store, something went wrong - clear it\n            logger.warning(f\"Type {ros2_type_name} was marked as registered but not in store, re-registering\")\n            del self._registered_types[ros2_type_name]\n\n        # If msg_definition is None, try to load from message registry\n        if msg_definition is None:\n            registry = get_registry()\n\n            # Special case: handle messages with empty definitions (like std_msgs/msg/Empty)\n            # If the .msg file exists and is empty, register it directly to prevent recursion\n            try:\n                msg_file = registry.get_msg_file_path(ros2_type_name)\n                if msg_file and msg_file.exists():\n                    with open(msg_file, 'r') as f:\n                        file_content = f.read()\n                    # If file is empty (valid for messages with no fields), register it directly\n                    if not file_content.strip():\n                        types = get_types_from_msg(\"\", ros2_type_name)\n                        self.store.register(types)\n                        # Find the actual key that was registered (same logic as below)\n                        actual_type_key = None\n                        for key in types.keys():\n                            if key == ros2_type_name:\n                                actual_type_key = key\n                                break\n                        if actual_type_key is None and types:\n                            actual_type_key = list(types.keys())[0]\n                        if actual_type_key:\n                            self._registered_types[ros2_type_name] = actual_type_key\n                            msg_class = self.store.types.get(actual_type_key)\n                            if msg_class is not None:\n                                return msg_class\n            except Exception:\n                # If file check or registration fails, fall through to registry loading\n                pass\n\n            # Check if this is a service request/response type\n            # Service types are like \"namespace/srv/ServiceName_Request\" or \"namespace/srv/ServiceName_Response\"\n            is_service_type = '/srv/' in ros2_type_name and ('_Request' in ros2_type_name or '_Response' in ros2_type_name)\n\n            if is_service_type:\n                # For service types, we need to load the service type first\n                # Extract service type from request/response type\n                # e.g., \"example_interfaces/srv/AddTwoInts_Request\" -&gt; \"example_interfaces/srv/AddTwoInts\"\n                if ros2_type_name.endswith('_Request'):\n                    srv_type = ros2_type_name[:-8]  # Remove \"_Request\"\n                elif ros2_type_name.endswith('_Response'):\n                    srv_type = ros2_type_name[:-9]  # Remove \"_Response\"\n                else:\n                    srv_type = None\n\n                if srv_type:\n                    # Load the service type - this will register both request and response types\n                    if load_service_type(srv_type):\n                        # After loading, check if the type is now in _registered_types\n                        # (load_service_type calls register_message_type which adds it)\n                        if ros2_type_name in self._registered_types:\n                            # Type was registered, get it from store using the actual key\n                            actual_key = self._registered_types[ros2_type_name]\n                            if isinstance(actual_key, str):\n                                msg_class = self.store.types.get(actual_key)\n                                if msg_class is not None:\n                                    return msg_class\n\n                        # If not found via _registered_types, try direct lookup (both original and converted names)\n                        # Try converted name first (rosbags stores service types with /srv/msg/)\n                        converted_name = ros2_type_name.replace('/srv/', '/srv/msg/')\n                        msg_class = self.store.types.get(converted_name)\n                        if msg_class is not None:\n                            self._registered_types[ros2_type_name] = converted_name\n                            return msg_class\n\n                        # Try original name\n                        msg_class = self.store.types.get(ros2_type_name)\n                        if msg_class is not None:\n                            self._registered_types[ros2_type_name] = ros2_type_name\n                            return msg_class\n\n            # For regular message types, use the existing logic\n            if registry.is_loaded(ros2_type_name):\n                # Already loaded, check if it's in the store (try both original and converted names)\n                msg_class = self.store.types.get(ros2_type_name)\n                if msg_class is None and '/srv/' in ros2_type_name:\n                    # Try converted name for service types\n                    converted_name = ros2_type_name.replace('/srv/', '/srv/msg/')\n                    msg_class = self.store.types.get(converted_name)\n                    if msg_class is not None:\n                        self._registered_types[ros2_type_name] = converted_name\n                        return msg_class\n                if msg_class is not None:\n                    # Store the mapping (use original name as key if found directly)\n                    self._registered_types[ros2_type_name] = ros2_type_name\n                    return msg_class\n            elif registry.load_message_type(ros2_type_name):\n                # Successfully loaded from registry, try both original and converted names\n                msg_class = self.store.types.get(ros2_type_name)\n                if msg_class is None and '/srv/' in ros2_type_name:\n                    # Try converted name for service types\n                    converted_name = ros2_type_name.replace('/srv/', '/srv/msg/')\n                    msg_class = self.store.types.get(converted_name)\n                    if msg_class is not None:\n                        self._registered_types[ros2_type_name] = converted_name\n                        return msg_class\n                if msg_class is not None:\n                    # Store the mapping (use original name as key if found directly)\n                    self._registered_types[ros2_type_name] = ros2_type_name\n                    return msg_class\n\n            # If we get here, the type wasn't found or couldn't be loaded\n            raise ValueError(\n                f\"Message type {ros2_type_name} not found in registry and no definition provided. \"\n                f\"Please provide msg_definition or ensure the message type is loaded.\"\n            )\n\n        # Register the type from the provided definition\n        try:\n            types = get_types_from_msg(msg_definition, ros2_type_name)\n            self.store.register(types)\n\n            # get_types_from_msg may convert the type name (e.g., srv/TypeName -&gt; srv/msg/TypeName)\n            # Find the actual key that was registered in the store\n            actual_type_key = None\n            for key in types.keys():\n                # Check if this key matches our type name\n                if key == ros2_type_name:\n                    actual_type_key = key\n                    break\n                # Handle conversion: srv/TypeName -&gt; srv/msg/TypeName\n                # Check if the key is a converted version of our type name\n                if '/srv/' in ros2_type_name and '/srv/msg/' in key:\n                    # Extract the base name (everything after srv/)\n                    our_base = ros2_type_name.split('/srv/')[1]\n                    store_base = key.split('/srv/msg/')[1]\n                    if our_base == store_base:\n                        actual_type_key = key\n                        break\n\n            # If no match found, use the first (and likely only) key from types\n            if actual_type_key is None and types:\n                actual_type_key = list(types.keys())[0]\n\n            # Store mapping: our type name -&gt; actual store key\n            if actual_type_key:\n                self._registered_types[ros2_type_name] = actual_type_key\n                msg_class = self.store.types.get(actual_type_key)\n                if msg_class is not None:\n                    return msg_class\n        except Exception as e:\n            raise RuntimeError(\n                f\"Failed to register message type {ros2_type_name}: {e}\"\n            ) from e\n\n        # Handle name conversion: rosbags converts srv/TypeName to srv/msg/TypeName\n        # Try original name first, then converted name\n        msg_class = self.store.types.get(ros2_type_name)\n        if msg_class is None:\n            # Try with /msg/ inserted (for service types: srv/ -&gt; srv/msg/)\n            if '/srv/' in ros2_type_name:\n                converted_name = ros2_type_name.replace('/srv/', '/srv/msg/')\n                msg_class = self.store.types.get(converted_name)\n                if msg_class is not None:\n                    # Cache the mapping for future lookups\n                    self._registered_types[ros2_type_name] = converted_name\n                    return msg_class\n\n        if msg_class is None:\n            # Provide helpful error message\n            tried_names = [ros2_type_name]\n            if '/srv/' in ros2_type_name:\n                tried_names.append(ros2_type_name.replace('/srv/', '/srv/msg/'))\n            available = [k for k in self.store.types.keys() if ros2_type_name.split('/')[-1] in k][:5]\n            raise KeyError(\n                f\"Message type {ros2_type_name} was registered but not found in store. \"\n                f\"Tried: {tried_names}. \"\n                f\"Available matching types: {available}\"\n            )\n        return msg_class\n\n    def get_next_node_id(self):\n        \"\"\"Get next available node ID\"\"\"\n        with self._lock:\n            node_id = self._node_counter\n            self._node_counter += 1\n            return node_id\n\n    def get_next_entity_id(self):\n        \"\"\"Get next available entity ID\"\"\"\n        with self._lock:\n            entity_id = self._entity_counter\n            self._entity_counter += 1\n            return entity_id\n\n    def generate_gid(self) -&gt; bytes:\n        \"\"\"Generate a unique GID (16 bytes)\"\"\"\n        # Use UUID to generate unique GID\n        uuid_bytes = uuid.uuid4().bytes\n        return uuid_bytes\n\n    def close(self):\n        \"\"\"Close the session\"\"\"\n        if self.session:\n            self.session.close()\n            self._instance = None\n</code></pre>"},{"location":"api/session/#zenoh_ros2_sdk.session.ZenohSession.get_instance","title":"<code>get_instance(router_ip: str = '127.0.0.1', router_port: int = 7447)</code>  <code>classmethod</code>","text":"<p>Get or create singleton instance</p> Source code in <code>zenoh_ros2_sdk/session.py</code> <pre><code>@classmethod\ndef get_instance(cls, router_ip: str = \"127.0.0.1\", router_port: int = 7447):\n    \"\"\"Get or create singleton instance\"\"\"\n    if cls._instance is None:\n        with cls._lock:\n            if cls._instance is None:\n                cls._instance = cls(router_ip, router_port)\n    return cls._instance\n</code></pre>"},{"location":"api/session/#zenoh_ros2_sdk.session.ZenohSession.register_message_type","title":"<code>register_message_type(msg_definition: Optional[str], ros2_type_name: str)</code>","text":"<p>Register a ROS2 message type</p> Source code in <code>zenoh_ros2_sdk/session.py</code> <pre><code>def register_message_type(self, msg_definition: Optional[str], ros2_type_name: str):\n    \"\"\"Register a ROS2 message type\"\"\"\n    # Check if already registered and in store\n    if ros2_type_name in self._registered_types:\n        # Get the actual store key (may be converted name for service types)\n        actual_key = self._registered_types[ros2_type_name]\n        if isinstance(actual_key, str):\n            # actual_key is the store key\n            msg_class = self.store.types.get(actual_key)\n            if msg_class is not None:\n                return msg_class\n        else:\n            # actual_key is the types dict (old format), try direct lookup\n            msg_class = self.store.types.get(ros2_type_name)\n            if msg_class is not None:\n                return msg_class\n            # Try converted name for service types\n            if '/srv/' in ros2_type_name:\n                converted_name = ros2_type_name.replace('/srv/', '/srv/msg/')\n                msg_class = self.store.types.get(converted_name)\n                if msg_class is not None:\n                    # Update mapping to use converted name\n                    self._registered_types[ros2_type_name] = converted_name\n                    return msg_class\n\n        # If in _registered_types but not in store, something went wrong - clear it\n        logger.warning(f\"Type {ros2_type_name} was marked as registered but not in store, re-registering\")\n        del self._registered_types[ros2_type_name]\n\n    # If msg_definition is None, try to load from message registry\n    if msg_definition is None:\n        registry = get_registry()\n\n        # Special case: handle messages with empty definitions (like std_msgs/msg/Empty)\n        # If the .msg file exists and is empty, register it directly to prevent recursion\n        try:\n            msg_file = registry.get_msg_file_path(ros2_type_name)\n            if msg_file and msg_file.exists():\n                with open(msg_file, 'r') as f:\n                    file_content = f.read()\n                # If file is empty (valid for messages with no fields), register it directly\n                if not file_content.strip():\n                    types = get_types_from_msg(\"\", ros2_type_name)\n                    self.store.register(types)\n                    # Find the actual key that was registered (same logic as below)\n                    actual_type_key = None\n                    for key in types.keys():\n                        if key == ros2_type_name:\n                            actual_type_key = key\n                            break\n                    if actual_type_key is None and types:\n                        actual_type_key = list(types.keys())[0]\n                    if actual_type_key:\n                        self._registered_types[ros2_type_name] = actual_type_key\n                        msg_class = self.store.types.get(actual_type_key)\n                        if msg_class is not None:\n                            return msg_class\n        except Exception:\n            # If file check or registration fails, fall through to registry loading\n            pass\n\n        # Check if this is a service request/response type\n        # Service types are like \"namespace/srv/ServiceName_Request\" or \"namespace/srv/ServiceName_Response\"\n        is_service_type = '/srv/' in ros2_type_name and ('_Request' in ros2_type_name or '_Response' in ros2_type_name)\n\n        if is_service_type:\n            # For service types, we need to load the service type first\n            # Extract service type from request/response type\n            # e.g., \"example_interfaces/srv/AddTwoInts_Request\" -&gt; \"example_interfaces/srv/AddTwoInts\"\n            if ros2_type_name.endswith('_Request'):\n                srv_type = ros2_type_name[:-8]  # Remove \"_Request\"\n            elif ros2_type_name.endswith('_Response'):\n                srv_type = ros2_type_name[:-9]  # Remove \"_Response\"\n            else:\n                srv_type = None\n\n            if srv_type:\n                # Load the service type - this will register both request and response types\n                if load_service_type(srv_type):\n                    # After loading, check if the type is now in _registered_types\n                    # (load_service_type calls register_message_type which adds it)\n                    if ros2_type_name in self._registered_types:\n                        # Type was registered, get it from store using the actual key\n                        actual_key = self._registered_types[ros2_type_name]\n                        if isinstance(actual_key, str):\n                            msg_class = self.store.types.get(actual_key)\n                            if msg_class is not None:\n                                return msg_class\n\n                    # If not found via _registered_types, try direct lookup (both original and converted names)\n                    # Try converted name first (rosbags stores service types with /srv/msg/)\n                    converted_name = ros2_type_name.replace('/srv/', '/srv/msg/')\n                    msg_class = self.store.types.get(converted_name)\n                    if msg_class is not None:\n                        self._registered_types[ros2_type_name] = converted_name\n                        return msg_class\n\n                    # Try original name\n                    msg_class = self.store.types.get(ros2_type_name)\n                    if msg_class is not None:\n                        self._registered_types[ros2_type_name] = ros2_type_name\n                        return msg_class\n\n        # For regular message types, use the existing logic\n        if registry.is_loaded(ros2_type_name):\n            # Already loaded, check if it's in the store (try both original and converted names)\n            msg_class = self.store.types.get(ros2_type_name)\n            if msg_class is None and '/srv/' in ros2_type_name:\n                # Try converted name for service types\n                converted_name = ros2_type_name.replace('/srv/', '/srv/msg/')\n                msg_class = self.store.types.get(converted_name)\n                if msg_class is not None:\n                    self._registered_types[ros2_type_name] = converted_name\n                    return msg_class\n            if msg_class is not None:\n                # Store the mapping (use original name as key if found directly)\n                self._registered_types[ros2_type_name] = ros2_type_name\n                return msg_class\n        elif registry.load_message_type(ros2_type_name):\n            # Successfully loaded from registry, try both original and converted names\n            msg_class = self.store.types.get(ros2_type_name)\n            if msg_class is None and '/srv/' in ros2_type_name:\n                # Try converted name for service types\n                converted_name = ros2_type_name.replace('/srv/', '/srv/msg/')\n                msg_class = self.store.types.get(converted_name)\n                if msg_class is not None:\n                    self._registered_types[ros2_type_name] = converted_name\n                    return msg_class\n            if msg_class is not None:\n                # Store the mapping (use original name as key if found directly)\n                self._registered_types[ros2_type_name] = ros2_type_name\n                return msg_class\n\n        # If we get here, the type wasn't found or couldn't be loaded\n        raise ValueError(\n            f\"Message type {ros2_type_name} not found in registry and no definition provided. \"\n            f\"Please provide msg_definition or ensure the message type is loaded.\"\n        )\n\n    # Register the type from the provided definition\n    try:\n        types = get_types_from_msg(msg_definition, ros2_type_name)\n        self.store.register(types)\n\n        # get_types_from_msg may convert the type name (e.g., srv/TypeName -&gt; srv/msg/TypeName)\n        # Find the actual key that was registered in the store\n        actual_type_key = None\n        for key in types.keys():\n            # Check if this key matches our type name\n            if key == ros2_type_name:\n                actual_type_key = key\n                break\n            # Handle conversion: srv/TypeName -&gt; srv/msg/TypeName\n            # Check if the key is a converted version of our type name\n            if '/srv/' in ros2_type_name and '/srv/msg/' in key:\n                # Extract the base name (everything after srv/)\n                our_base = ros2_type_name.split('/srv/')[1]\n                store_base = key.split('/srv/msg/')[1]\n                if our_base == store_base:\n                    actual_type_key = key\n                    break\n\n        # If no match found, use the first (and likely only) key from types\n        if actual_type_key is None and types:\n            actual_type_key = list(types.keys())[0]\n\n        # Store mapping: our type name -&gt; actual store key\n        if actual_type_key:\n            self._registered_types[ros2_type_name] = actual_type_key\n            msg_class = self.store.types.get(actual_type_key)\n            if msg_class is not None:\n                return msg_class\n    except Exception as e:\n        raise RuntimeError(\n            f\"Failed to register message type {ros2_type_name}: {e}\"\n        ) from e\n\n    # Handle name conversion: rosbags converts srv/TypeName to srv/msg/TypeName\n    # Try original name first, then converted name\n    msg_class = self.store.types.get(ros2_type_name)\n    if msg_class is None:\n        # Try with /msg/ inserted (for service types: srv/ -&gt; srv/msg/)\n        if '/srv/' in ros2_type_name:\n            converted_name = ros2_type_name.replace('/srv/', '/srv/msg/')\n            msg_class = self.store.types.get(converted_name)\n            if msg_class is not None:\n                # Cache the mapping for future lookups\n                self._registered_types[ros2_type_name] = converted_name\n                return msg_class\n\n    if msg_class is None:\n        # Provide helpful error message\n        tried_names = [ros2_type_name]\n        if '/srv/' in ros2_type_name:\n            tried_names.append(ros2_type_name.replace('/srv/', '/srv/msg/'))\n        available = [k for k in self.store.types.keys() if ros2_type_name.split('/')[-1] in k][:5]\n        raise KeyError(\n            f\"Message type {ros2_type_name} was registered but not found in store. \"\n            f\"Tried: {tried_names}. \"\n            f\"Available matching types: {available}\"\n        )\n    return msg_class\n</code></pre>"},{"location":"api/session/#zenoh_ros2_sdk.session.ZenohSession.get_next_node_id","title":"<code>get_next_node_id()</code>","text":"<p>Get next available node ID</p> Source code in <code>zenoh_ros2_sdk/session.py</code> <pre><code>def get_next_node_id(self):\n    \"\"\"Get next available node ID\"\"\"\n    with self._lock:\n        node_id = self._node_counter\n        self._node_counter += 1\n        return node_id\n</code></pre>"},{"location":"api/session/#zenoh_ros2_sdk.session.ZenohSession.get_next_entity_id","title":"<code>get_next_entity_id()</code>","text":"<p>Get next available entity ID</p> Source code in <code>zenoh_ros2_sdk/session.py</code> <pre><code>def get_next_entity_id(self):\n    \"\"\"Get next available entity ID\"\"\"\n    with self._lock:\n        entity_id = self._entity_counter\n        self._entity_counter += 1\n        return entity_id\n</code></pre>"},{"location":"api/session/#zenoh_ros2_sdk.session.ZenohSession.generate_gid","title":"<code>generate_gid() -&gt; bytes</code>","text":"<p>Generate a unique GID (16 bytes)</p> Source code in <code>zenoh_ros2_sdk/session.py</code> <pre><code>def generate_gid(self) -&gt; bytes:\n    \"\"\"Generate a unique GID (16 bytes)\"\"\"\n    # Use UUID to generate unique GID\n    uuid_bytes = uuid.uuid4().bytes\n    return uuid_bytes\n</code></pre>"},{"location":"api/session/#zenoh_ros2_sdk.session.ZenohSession.close","title":"<code>close()</code>","text":"<p>Close the session</p> Source code in <code>zenoh_ros2_sdk/session.py</code> <pre><code>def close(self):\n    \"\"\"Close the session\"\"\"\n    if self.session:\n        self.session.close()\n        self._instance = None\n</code></pre>"},{"location":"api/subscriber/","title":"<code>subscriber</code>","text":"<p>ROS2Subscriber - ROS2 Subscriber using Zenoh</p>"},{"location":"api/subscriber/#zenoh_ros2_sdk.subscriber.ROS2Subscriber","title":"<code>ROS2Subscriber</code>","text":"<p>ROS2 Subscriber using Zenoh</p> Source code in <code>zenoh_ros2_sdk/subscriber.py</code> <pre><code>class ROS2Subscriber:\n    \"\"\"ROS2 Subscriber using Zenoh\"\"\"\n\n    def __init__(\n        self,\n        topic: str,\n        msg_type: str,\n        callback: Callable,\n        msg_definition: Optional[str] = None,\n        node_name: Optional[str] = None,\n        namespace: str = \"/\",\n        domain_id: Optional[int] = None,\n        router_ip: str = \"127.0.0.1\",\n        router_port: int = 7447,\n        type_hash: Optional[str] = None,\n        qos: Optional[object] = None,\n    ):\n        \"\"\"\n        Create a ROS2 subscriber\n\n        Args:\n            topic: ROS2 topic name (e.g. `/chatter`).\n            msg_type: ROS2 message type (e.g. `std_msgs/msg/String`).\n            callback: Callback function(msg) called when message is received\n            msg_definition: Message definition text (None to auto-load from registry)\n            node_name: Node name (auto-generated if None)\n            namespace: Node namespace\n            domain_id: ROS domain ID (defaults to ROS_DOMAIN_ID or 0)\n            router_ip: Zenoh router IP\n            router_port: Zenoh router port\n            type_hash: Message type hash (auto-detected if None)\n            qos: QoS used for liveliness discovery tokens.\n                Accepts `QosProfile`, an encoded rmw_zenoh QoS string, or `None` for default.\n\n        Raises:\n            ValueError: If the type hash cannot be computed because message definitions are missing.\n            TypeError: If Zenoh delivers an unexpected payload type (see `_listener`).\n        \"\"\"\n        self.topic = topic\n        self.msg_type = msg_type\n        self.callback = callback\n        self.domain_id = resolve_domain_id(domain_id)\n        self.namespace = namespace\n        self.node_name = node_name or f\"zenoh_subscriber_{uuid.uuid4().hex[:8]}\"\n        # QoS is only used for liveliness discovery tokens. It does not affect the\n        # data keyexpr subscription (which is topic/type-hash based).\n        _, self.qos = self._normalize_qos(qos, default=DEFAULT_QOS_PROFILE, fallback=DEFAULT_QOS_PROFILE.encode())\n\n        # Get or create shared session\n        self.session_mgr = ZenohSession.get_instance(router_ip, router_port)\n\n        # Register message type\n        self.session_mgr.register_message_type(msg_definition, msg_type)\n\n        # Get DDS type name\n        self.dds_type_name = ros2_to_dds_type(msg_type)\n\n        # Get type hash if not provided\n        if type_hash is None:\n            # Get message definition for hash computation\n            # If msg_definition is None, load from registry (same as register_message_type does)\n            # Empty string (\"\") is valid for messages with no fields (like std_msgs/msg/Empty)\n            hash_msg_definition = msg_definition\n            if hash_msg_definition is None:\n                # Load from registry (same logic as register_message_type)\n                try:\n                    registry = get_registry()\n                    msg_file = registry.get_msg_file_path(msg_type)\n                    if msg_file and msg_file.exists():\n                        with open(msg_file, 'r') as f:\n                            hash_msg_definition = f.read()\n                except Exception as e:\n                    # Registry not available or file not found - will raise ValueError below\n                    logger.debug(f\"Could not load message definition from registry for {msg_type}: {e}\")\n                    pass\n\n            # If still None after trying to load, raise error\n            if hash_msg_definition is None:\n                raise ValueError(\n                    f\"Cannot compute type hash for {msg_type}: message definition not provided. \"\n                    \"Please provide msg_definition or ensure the message type is loaded in the registry.\"\n                )\n\n            # Get dependencies from message registry if available (recursively)\n            dependencies = None\n            try:\n                registry = get_registry()\n                # Load all dependencies recursively using shared utility function\n                dependencies = load_dependencies_recursive(msg_type, hash_msg_definition, registry)\n            except Exception as e:\n                # If dependency loading fails, continue without dependencies\n                # Type hash computation will still work, just without nested type info\n                logger.debug(f\"Could not load dependencies for {msg_type}: {e}\")\n                pass\n\n            type_hash = get_type_hash(msg_type, msg_definition=hash_msg_definition, dependencies=dependencies)\n        self.type_hash = type_hash\n\n        # Generate IDs used in ROS2 liveliness discovery (mirrors publisher/service patterns)\n        self.subscriber_gid = self.session_mgr.generate_gid()\n        self.node_id = self.session_mgr.get_next_node_id()\n        self.entity_id = self.session_mgr.get_next_entity_id()\n\n        # Build keyexpr\n        self.keyexpr = topic_keyexpr(self.domain_id, topic, self.dds_type_name, type_hash)\n\n        # Declare liveliness tokens so ROS2 nodes that publish-on-subscribe (e.g., image_transport)\n        # will see this subscriber.\n        self._declare_liveliness_tokens()\n\n        # Create subscriber\n        self.sub = self.session_mgr.session.declare_subscriber(self.keyexpr, self._listener)\n        self._closed = False\n\n        # For transient_local durability, query for cached/historical data\n        # This mimics rmw_zenoh's AdvancedSubscriber behavior\n        self.qos_profile, _ = self._normalize_qos(qos, default=DEFAULT_QOS_PROFILE, fallback=DEFAULT_QOS_PROFILE.encode())\n        if self.qos_profile.durability == QosDurability.TRANSIENT_LOCAL:\n            self._query_historical_data()\n\n    @staticmethod\n    def _normalize_qos(\n        qos: Optional[object],\n        *,\n        default: QosProfile,\n        fallback: str,\n    ) -&gt; tuple[QosProfile, str]:\n        \"\"\"\n        Subscriber only needs the encoded QoS string for tokens, but we normalize\n        similarly to publisher for API consistency.\n        \"\"\"\n        if qos is None:\n            return default, fallback\n        if isinstance(qos, QosProfile):\n            return qos, qos.encode()\n        if isinstance(qos, str):\n            # User provided an authoritative encoded QoS string. It must be parseable.\n            return QosProfile.decode(qos), qos\n        return default, fallback\n\n    def _declare_liveliness_tokens(self):\n        \"\"\"Declare liveliness tokens for ROS2 discovery\"\"\"\n        node = NodeEntity(\n            domain_id=self.domain_id,\n            session_id=self.session_mgr.session_id,\n            node_id=self.node_id,\n            node_name=self.node_name,\n            namespace=self.namespace,\n        )\n        ep = EndpointEntity(\n            node=node,\n            entity_id=self.entity_id,\n            kind=EntityKind.SUBSCRIPTION,\n            name=self.topic,\n            dds_type_name=self.dds_type_name,\n            type_hash=self.type_hash,\n            qos=self.qos,\n            gid=self.subscriber_gid,\n        )\n\n        self.node_token = self.session_mgr.liveliness.declare_token(node_liveliness_keyexpr(node))\n        self.subscriber_token = self.session_mgr.liveliness.declare_token(endpoint_liveliness_keyexpr(ep))\n\n    def _listener(self, sample):\n        \"\"\"Internal message listener\"\"\"\n        self._process_sample(sample)\n\n    def _process_sample(self, sample):\n        \"\"\"Process a Zenoh sample (from subscription or query reply)\"\"\"\n        try:\n            payload = getattr(sample, \"payload\", None)\n            if payload is None:\n                raise ValueError(\"Zenoh sample has no payload\")\n\n            # Verified in-container: sample.payload is a ZBytes and supports to_bytes().\n            # Prefer to_bytes() because it is explicit and version-stable.\n            if hasattr(payload, \"to_bytes\"):\n                cdr_bytes = payload.to_bytes()\n                if not isinstance(cdr_bytes, (bytes, bytearray)):\n                    raise TypeError(\n                        \"Zenoh payload.to_bytes() returned a non-bytes value: \"\n                        f\"type={type(cdr_bytes)}\"\n                    )\n                cdr_bytes = bytes(cdr_bytes)\n            elif isinstance(payload, (bytes, bytearray)):\n                cdr_bytes = bytes(payload)\n            elif isinstance(payload, memoryview):\n                cdr_bytes = payload.tobytes()\n            else:\n                raise TypeError(\n                    \"Unsupported Zenoh payload type. Expected an object with to_bytes(), \"\n                    f\"or bytes-like payload. Got type={type(payload)}. \"\n                    f\"Has to_bytes={hasattr(payload, 'to_bytes')}. \"\n                    f\"Payload repr={repr(payload)[:200]}\"\n                )\n\n            if not cdr_bytes:\n                raise ValueError(\"Received empty payload\")\n\n            msg = self.session_mgr.store.deserialize_cdr(cdr_bytes, self.msg_type)\n            self.callback(msg)\n        except Exception as e:\n            logger.error(f\"Error deserializing message on topic {self.topic}: {e}\", exc_info=True)\n\n    def _query_historical_data(self):\n        \"\"\"Query for cached data from transient_local publishers.\n\n        rmw_zenoh uses AdvancedPublisher which caches messages at:\n            &lt;key_expr&gt;/@adv/pub/&lt;zenoh_id&gt;/&lt;entity_id&gt;/_\n\n        The `_anyke` selector parameter allows replies on any key expression.\n        Zenoh uses ';' as parameter separator (not '&amp;').\n        \"\"\"\n        publishers = self._discover_publishers()\n        if not publishers:\n            logger.debug(f\"No transient_local publishers for {self.topic}\")\n            return\n\n        max_samples = self.qos_profile.history_depth\n        total_replies = 0\n\n        for zenoh_id in publishers:\n            # Query the AdvancedPublisher cache with _anyke to accept any reply key\n            selector = f\"{self.keyexpr}/@adv/pub/{zenoh_id}/**?_anyke;_max={max_samples}\"\n\n            try:\n                for reply in self.session_mgr.session.get(selector, timeout=2.0):\n                    if reply.ok is not None:\n                        total_replies += 1\n                        self._process_sample(reply.ok)\n                    elif reply.err is not None:\n                        logger.warning(f\"Query error for {self.topic}: {reply.err}\")\n            except Exception as e:\n                logger.warning(f\"Failed to query publisher {zenoh_id}: {e}\")\n\n        if total_replies &gt; 0:\n            logger.debug(f\"Received {total_replies} cached samples for {self.topic}\")\n\n    def _discover_publishers(self) -&gt; list[str]:\n        \"\"\"Discover publishers for this topic via liveliness tokens.\n\n        Returns:\n            List of zenoh_id strings for each publisher found.\n        \"\"\"\n        publishers = set()\n\n        # rmw_zenoh liveliness token format:\n        # @ros2_lv/&lt;domain&gt;/&lt;zenoh_id&gt;/&lt;seq&gt;/&lt;entity_id&gt;/MP/&lt;gid_hi&gt;/&lt;gid_lo&gt;/&lt;node&gt;/%&lt;topic&gt;/&lt;dds_type&gt;/&lt;type_hash&gt;/&lt;qos&gt;\n        lv_pattern = (\n            f\"@ros2_lv/{self.domain_id}/*/*/*/MP/*/*/*\"\n            f\"/%{self.topic.lstrip('/')}/{self.dds_type_name}/{self.type_hash}/*\"\n        )\n\n        try:\n            replies = self.session_mgr.liveliness.get(lv_pattern, timeout=2.0)\n            for reply in replies:\n                if reply.ok is not None:\n                    parts = str(reply.ok.key_expr).split('/')\n                    if len(parts) &gt; 2:\n                        publishers.add(parts[2])  # zenoh_id is at index 2\n        except Exception as e:\n            logger.warning(f\"Failed to discover publishers for {self.topic}: {e}\")\n\n        return list(publishers)\n\n    def close(self):\n        \"\"\"\n        Close the subscriber and cleanup resources.\n\n        This method is idempotent - it's safe to call multiple times.\n        \"\"\"\n        # Check if already closed\n        if hasattr(self, '_closed') and self._closed:\n            return\n\n        try:\n            # Undeclare liveliness tokens first (best-effort)\n            if hasattr(self, \"subscriber_token\") and self.subscriber_token is not None:\n                self.subscriber_token.undeclare()\n                self.subscriber_token = None\n            if hasattr(self, \"node_token\") and self.node_token is not None:\n                self.node_token.undeclare()\n                self.node_token = None\n\n            if hasattr(self, 'sub') and self.sub is not None:\n                # Zenoh subscribers have an undeclare() method to explicitly remove them\n                # This is the proper way to clean up a subscriber\n                if hasattr(self.sub, 'undeclare'):\n                    self.sub.undeclare()\n                # Mark as closed\n                self.sub = None\n            self._closed = True\n        except (AttributeError, RuntimeError) as e:\n            # AttributeError: subscriber doesn't exist or undeclare method not available\n            # RuntimeError: Zenoh runtime errors\n            logger.debug(f\"Error during subscriber cleanup for topic {self.topic}: {e}\")\n            # Mark as closed even if undeclare failed to prevent retry loops\n            self._closed = True\n        except Exception as e:\n            # Catch any other unexpected exceptions during cleanup\n            # Log at warning level since this is unexpected\n            logger.warning(f\"Unexpected error during subscriber cleanup for topic {self.topic}: {e}\")\n            self._closed = True\n</code></pre>"},{"location":"api/subscriber/#zenoh_ros2_sdk.subscriber.ROS2Subscriber.close","title":"<code>close()</code>","text":"<p>Close the subscriber and cleanup resources.</p> <p>This method is idempotent - it's safe to call multiple times.</p> Source code in <code>zenoh_ros2_sdk/subscriber.py</code> <pre><code>def close(self):\n    \"\"\"\n    Close the subscriber and cleanup resources.\n\n    This method is idempotent - it's safe to call multiple times.\n    \"\"\"\n    # Check if already closed\n    if hasattr(self, '_closed') and self._closed:\n        return\n\n    try:\n        # Undeclare liveliness tokens first (best-effort)\n        if hasattr(self, \"subscriber_token\") and self.subscriber_token is not None:\n            self.subscriber_token.undeclare()\n            self.subscriber_token = None\n        if hasattr(self, \"node_token\") and self.node_token is not None:\n            self.node_token.undeclare()\n            self.node_token = None\n\n        if hasattr(self, 'sub') and self.sub is not None:\n            # Zenoh subscribers have an undeclare() method to explicitly remove them\n            # This is the proper way to clean up a subscriber\n            if hasattr(self.sub, 'undeclare'):\n                self.sub.undeclare()\n            # Mark as closed\n            self.sub = None\n        self._closed = True\n    except (AttributeError, RuntimeError) as e:\n        # AttributeError: subscriber doesn't exist or undeclare method not available\n        # RuntimeError: Zenoh runtime errors\n        logger.debug(f\"Error during subscriber cleanup for topic {self.topic}: {e}\")\n        # Mark as closed even if undeclare failed to prevent retry loops\n        self._closed = True\n    except Exception as e:\n        # Catch any other unexpected exceptions during cleanup\n        # Log at warning level since this is unexpected\n        logger.warning(f\"Unexpected error during subscriber cleanup for topic {self.topic}: {e}\")\n        self._closed = True\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>This section is for contributors working on the repository (docs, docstrings, tests, etc.).</p> <ul> <li>If you\u2019re here to use the SDK, start with <code>getting-started.md</code>.</li> </ul>"},{"location":"contributing/docs/","title":"Documentation (MkDocs)","text":"<p>These instructions are for building/serving the documentation site locally.</p>"},{"location":"contributing/docs/#install-docs-dependencies","title":"Install docs dependencies","text":"<p>From the repo root:</p> <pre><code>pip install -e \".[docs]\"\n</code></pre>"},{"location":"contributing/docs/#serve-locally","title":"Serve locally","text":"<pre><code>mkdocs serve\n</code></pre>"},{"location":"contributing/docs/#container-note-jetsonnvidia-pip-indexes","title":"Container note (Jetson/NVIDIA pip indexes)","text":"<p>Some container images set <code>PIP_INDEX_URL</code> to Jetson/NVIDIA indexes which may not contain build dependencies like <code>setuptools</code>. To force PyPI, set:</p> <pre><code>export PIP_INDEX_URL=https://pypi.org/simple\nunset PIP_EXTRA_INDEX_URL\n</code></pre>"},{"location":"contributing/docstrings/","title":"Docstring Guidelines (Google style)","text":"<p>This project generates web API docs from docstrings using MkDocs + mkdocstrings.</p>"},{"location":"contributing/docstrings/#goals","title":"Goals","text":"<ul> <li>Keep docstrings accurate (never describe behavior that isn\u2019t implemented).</li> <li>Make sharp edges explicit (required env vars, Zenoh API constraints, expected payload shapes).</li> <li>Provide copy/paste examples for the most used APIs.</li> </ul>"},{"location":"contributing/docstrings/#style-google","title":"Style (Google)","text":"<p>Use:</p> <ul> <li>One-line summary</li> <li>Blank line</li> <li>Optional longer description</li> <li><code>Args:</code> / <code>Returns:</code> / <code>Raises:</code></li> <li><code>Examples:</code> when it helps adoption</li> </ul> <p>Example:</p> <pre><code>def foo(x: int) -&gt; int:\n    \"\"\"Double an integer.\n\n    Args:\n        x: Input integer.\n\n    Returns:\n        The doubled value.\n\n    Raises:\n        ValueError: If `x` is negative.\n    \"\"\"\n    if x &lt; 0:\n        raise ValueError(\"x must be non-negative\")\n    return 2 * x\n</code></pre>"},{"location":"contributing/docstrings/#what-must-be-documented-public-apis","title":"What must be documented (public APIs)","text":"<p>For each public class/function:</p> <ul> <li>Args: types + meaning; mention accepted unions (e.g., <code>qos</code> accepts <code>QosProfile | str | None</code>).</li> <li>Returns: include \u201cNone on timeout/error\u201d if that\u2019s the contract.</li> <li>Raises: list concrete exceptions users should expect.</li> <li>Semantics:</li> <li>Data-plane keyexpr format</li> <li>Liveliness token behavior (<code>@ros2_lv/...</code>)</li> <li>Service attachment requirement and correlation key behavior</li> <li>Examples: minimal working examples (publish/subscribe, service callback, service queue mode).</li> </ul>"}]}